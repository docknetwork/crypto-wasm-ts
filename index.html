<!DOCTYPE html><html class="default" lang="en"><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="IE=edge"/><title>@docknetwork/crypto-wasm-ts</title><meta name="description" content="Documentation for @docknetwork/crypto-wasm-ts"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="assets/style.css"/><link rel="stylesheet" href="assets/highlight.css"/><script defer src="assets/main.js"></script><script async src="assets/icons.js" id="tsd-icons-script"></script><script async src="assets/search.js" id="tsd-search-script"></script><script async src="assets/navigation.js" id="tsd-nav-script"></script></head><body><script>document.documentElement.dataset.theme = localStorage.getItem("tsd-theme") || "os";document.body.style.display="none";setTimeout(() => app?app.showPage():document.body.style.removeProperty("display"),500)</script><header class="tsd-page-toolbar"><div class="tsd-toolbar-contents container"><div class="table-cell" id="tsd-search" data-base="."><div class="field"><label for="tsd-search-field" class="tsd-widget tsd-toolbar-icon search no-caption"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="assets/icons.svg#icon-search"></use></svg></label><input type="text" id="tsd-search-field" aria-label="Search"/></div><div class="field"><div id="tsd-toolbar-links"></div></div><ul class="results"><li class="state loading">Preparing search index...</li><li class="state failure">The search index is not available</li></ul><a href="index.html" class="title">@docknetwork/crypto-wasm-ts</a></div><div class="table-cell" id="tsd-widgets"><a href="#" class="tsd-widget tsd-toolbar-icon menu no-caption" data-toggle="menu" aria-label="Menu"><svg width="16" height="16" viewBox="0 0 16 16" fill="none"><use href="assets/icons.svg#icon-menu"></use></svg></a></div></div></header><div class="container container-main"><div class="col-content"><div class="tsd-page-title"><h1>@docknetwork/crypto-wasm-ts</h1></div><div class="tsd-panel tsd-typography"><a id="md:crypto-wasm-ts" class="tsd-anchor"></a><h1 class="tsd-anchor-link">crypto-wasm-ts<a href="#md:crypto-wasm-ts" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h1><p>This repository is a Typescript interface to <a href="https://github.com/docknetwork/crypto" target="_blank" class="external">Dock Labs' Rust crypto library</a>. It uses
the <a href="https://github.com/docknetwork/crypto-wasm" target="_blank" class="external">WASM wrapper</a>.</p>
<a id="md:contents" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Contents<a href="#md:contents" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><ul>
<li><a href="#md:crypto-wasm-ts">crypto-wasm-ts</a>
<ul>
<li><a href="#md:contents">Contents</a></li>
<li><a href="#md:getting-started">Getting started</a>
<ul>
<li><a href="#md:build">Build</a></li>
<li><a href="#md:test">Test</a></li>
</ul>
</li>
<li><a href="#md:overview">Overview</a>
<ul>
<li><a href="#md:bbs-signature">BBS Signature</a></li>
<li><a href="#md:accumulator">Accumulator</a></li>
<li><a href="#md:composite-proof">Composite proof</a></li>
</ul>
</li>
<li><a href="#md:usage">Usage</a>
<ul>
<li><a href="#md:bbs-signatures">BBS signatures</a>
<ul>
<li><a href="#md:setup">Setup</a></li>
<li><a href="#md:signing-and-verification">Signing and verification</a></li>
<li><a href="#md:proof-of-knowledge-of-signature">Proof of knowledge of signature</a></li>
</ul>
</li>
<li><a href="#md:accumulators">Accumulators</a>
<ul>
<li><a href="#md:setup-1">Setup</a></li>
<li><a href="#md:updating-the-accumulator">Updating the accumulator</a></li>
<li><a href="#md:generating-witnesses">Generating witnesses</a></li>
<li><a href="#md:updating-witnesses">Updating witnesses</a></li>
<li><a href="#md:prefilled-accumulator">Prefilled accumulator</a></li>
</ul>
</li>
<li><a href="#md:composite-proofs">Composite proofs</a>
<ul>
<li><a href="#md:terminology">Terminology</a></li>
<li><a href="#md:examples">Examples</a>
<ul>
<li><a href="#md:selective-disclosure">Selective disclosure</a></li>
<li><a href="#md:bbs-signatures-over-null-valued-messages">BBS signature over null-valued messages</a></li>
<li><a href="#md:multiple-bbs-signatures">Multiple BBS signatures</a></li>
<li><a href="#md:bbs-signature-together-with-accumulator-membership">BBS signature together with accumulator membership</a></li>
<li><a href="#md:getting-a-blind-signature">Getting a blind signature</a></li>
<li><a href="#md:pseudonyms">Pseudonyms</a></li>
<li><a href="#md:social-kyc">Social KYC</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#md:verifiable-encryption-using-saver">Verifiable encryption using SAVER</a>
<ul>
<li><a href="#md:encoding-for-verifiable-encryption">Encoding for verifiable encryption</a></li>
</ul>
</li>
<li><a href="#md:bound-check-range-proof">Bound check (range proof)</a>
<ul>
<li><a href="#md:encoding-for-negative-or-decimal-numbers">Encoding for negative or decimal numbers</a></li>
</ul>
</li>
<li><a href="#md:optimization">Optimization</a></li>
<li><a href="#md:working-with-messages-as-js-objects">Working with messages as JS objects</a></li>
<li><a href="#md:writing-predicates-in-circom">Writing predicates in Circom</a></li>
<li><a href="#md:anonymous-credentials">Anonymous credentials</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="md:getting-started" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Getting started<a href="#md:getting-started" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>To use this package within your project simply run</p>
<pre><code><span class="hl-0">npm</span><span class="hl-1"> </span><span class="hl-0">install</span><span class="hl-1"> @</span><span class="hl-0">docknetwork</span><span class="hl-1">/</span><span class="hl-0">crypto</span><span class="hl-1">-</span><span class="hl-0">wasm</span><span class="hl-1">-</span><span class="hl-0">ts</span>
</code><button>Copy</button></pre>

<p>Or with <a href="https://yarnpkg.com/" target="_blank" class="external">Yarn</a></p>
<pre><code><span class="hl-0">yarn</span><span class="hl-1"> </span><span class="hl-0">add</span><span class="hl-1"> @</span><span class="hl-0">docknetwork</span><span class="hl-1">/</span><span class="hl-0">crypto</span><span class="hl-1">-</span><span class="hl-0">wasm</span><span class="hl-1">-</span><span class="hl-0">ts</span>
</code><button>Copy</button></pre>

<a id="md:build" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Build<a href="#md:build" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>To build the project run:</p>
<pre><code><span class="hl-0">yarn</span><span class="hl-1"> </span><span class="hl-0">build</span>
</code><button>Copy</button></pre>

<a id="md:test" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Test<a href="#md:test" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>To run the all tests in the project run:</p>
<pre><code><span class="hl-0">yarn</span><span class="hl-1"> </span><span class="hl-0">test</span>
</code><button>Copy</button></pre>

<a id="md:overview" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Overview<a href="#md:overview" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Following is a conceptual explanation of the primitives.</p>
<a id="md:bbs-signatures" class="tsd-anchor"></a><h3 class="tsd-anchor-link">BBS Signatures<a href="#md:bbs-signatures" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Disclaimer: There's multiple variations of the BBS scheme available out there, of which BBS+ was thought to be the version that is proven to be secure. However, in a recent <a href="https://eprint.iacr.org/2023/275" target="_blank" class="external">paper</a>, it was proven that in the initial BBS design was secure, with even a smaller signature size. This version is also the one used in the <a href="https://identity.foundation/bbs-signature/draft-irtf-cfrg-bbs-signatures.html" target="_blank" class="external">IRTF standardization effort</a>.</p>
<p>The BBS signature Scheme (henceforth referred to as just BBS) allows for signing an ordered list of messages, producing a signature of constant size independent of the number
of messages. The signer needs to have a public-private keypair and signature parameters which are public values whose size
depends on the number of messages being signed. A verifier who needs to verify the signature needs to know the
signature parameters used to sign the messages and the public key of the signer. In the context of anonymous credentials,
messages are called attributes.<br>
BBS also allows a user to request a blind signature from a signer where the signer does not know 1 or more messages
from the list. The user can then unblind the blind signature to get a regular signature which can be verified by a verifier in
the usual way. Such blind signatures can be used to hide a user specific secret like a private key or some unique identifier
as a message in the message list and the signer does not become aware of the hidden message.<br>
With a BBS signature, a user in possession of the signature and messages and create a <a href="https://en.wikipedia.org/wiki/Proof_of_knowledge" target="_blank" class="external">zero-knowledge proof of knowledge</a>
of the signature and the corresponding signed messages such that he can prove to a verifier that he knows a signature and the
messages and optionally reveal one or more of the messages.<br>
A typical use of BBS signatures looks like:</p>
<ul>
<li>Signature parameters of the required size are assumed to exist and published at a public location. The signer can create
his own or reuse parameters created by another party.</li>
<li>Signer creates a public-private keypair and publishes the public key.
The keypair can be reused for signing other messages as well.</li>
<li>User requests a signature from the signer.</li>
<li>Signer signs the message list using the signature parameters and his private key.</li>
<li>User verifies the signature on the  message list using the signature parameters and signer's public key</li>
<li>User creates a proof of knowledge of the signature and message list and optionally reveals 1 or more messages to the verifier.</li>
<li>The verifier uses the signature parameters and signer's public key to verify this proof.
If successful, the verifier is convinced that the user does have a signature from the
signer and any messages revealed were part of the message list signed by the signer.</li>
</ul>
<a id="md:accumulator" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Accumulator<a href="#md:accumulator" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>An accumulator is a set-like data structure in which elements can be added or removed but the size of the accumulator remains constant.
However, an accumulator cannot be directly checked for presence of an element, an element needs to have accompanying data called
the witness (its the manager's signature on the element), the element and the witness and these together can be used to check the presence or absence of the element.
An accumulator can be considered similar to the root of the merkle tree where the inclusion proof is the witness of the element
(non-membership proofs aren't possible with simple merkle trees). As with merkle trees, as elements are added or removed from the accumulator,
the witness (inclusion proof) needs to be updated for the current accumulated value (root).</p>
<p>2 kinds of accumulators are provided, <strong>positive</strong> and <strong>universal</strong>.
Positive support only membership witnesses while universal support both membership and non-membership witnesses.
Creating non-membership witnesses is expensive however, and the cost depends on the number of members present in the accumulator.
Both accumulators are owned by an accumulator manager who has the private key to the accumulator
and only the owner can add or remove elements or create witnesses using the accumulator.<br>
An accumulator allows proving membership of a member (or non-member) and the corresponding witness in zero knowledge, meaning
a user in possession of an accumulator member (or non-member) and the witness can convince a verifier that he knows of an
element present (or absent) in the accumulator without revealing the element or the witness. Note, the like merkle trees,
witnesses (inclusion proof) are tied to the accumulated value (root) and need to be updated as accumulator changes.<br>
Witnesses can be updated either by the accumulator manager using his private key or the manager can publish witness update
information and the updates (additions and removals) and users can update their witnesses.
A typical use of accumulator looks like:</p>
<ul>
<li>Accumulator parameters are assumed to exist and published at a public location. The manager can create his own params or
reuse existing ones.</li>
<li>Accumulator manager creates a keypair and publishes the public key.</li>
<li>Accumulator manager initializes the accumulator and publishes the accumulator.</li>
<li>User requests an element to be added to the accumulator, then requests the membership witness from the manager.
The user could have also requested a non-membership witness for an absent element.</li>
<li>Signer checks whether requested element is not already present (in his database) and adds the element to the
accumulator if not already present. He publishes the new accumulator and creates a (non)membership witness and sends to the user.</li>
<li>User verifies the (non)membership using the element, the witness, the new accumulated value and the accumulator params and signer's public key.</li>
<li>To prove knowledge of (non)membership in zero knowledge, user and verifier agree on a proving key. Anyone can generate this.</li>
<li>User can create a proof of knowledge of the element and the witness corresponding to the accumulator.</li>
<li>Verifier can verify above proof using the current accumulator, the parameters and signer's public key and is convinced
that the user knows of an element and its witness and the (non)-membership.</li>
</ul>
<a id="md:composite-proof" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Composite proof<a href="#md:composite-proof" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The above primitives can be combined using the composite proof system. An example is (in zero knowledge) proving knowledge of 2
different signatures and the message lists.
Another example is proving knowledge of the signature and messages and certain message's presence (absence) in an accumulator.
Or the knowledge of 5 signatures and proving certain message is the same in the 5 message lists.</p>
<a id="md:usage" class="tsd-anchor"></a><h2 class="tsd-anchor-link">Usage<a href="#md:usage" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h2><p>Before calling any function that calls the underlying WASM, use <code>initializeWasm</code> to load the WASM module.
This function returns a promise which is resolved once the WASM module is successfully loaded.</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">initializeWasm</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><br/><span class="hl-4">// Load the WASM module</span><br/><span class="hl-2">await</span><span class="hl-1"> </span><span class="hl-5">initializeWasm</span><span class="hl-1">();</span>
</code><button type="button">Copy</button></pre>

<a id="md:supported-signature-schemes" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Supported Signature Schemes<a href="#md:supported-signature-schemes" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The library has support for BBS, BBS+, PS, and BBDT16 schemes.<br>
Although they're similar in many aspects, specially for BBS and BBS, you're advised to consult the tests for changes
between the different schemes.
However, you can make a good guess just by looking at the schema <a href="./tests/scheme.ts#80">here</a>.</p>
<p>For all the following examples, BBS will be used, but the concepts should be transferable to other schemes.</p>
<a id="md:bbs-signatures-1" class="tsd-anchor"></a><h3 class="tsd-anchor-link">BBS signatures<a href="#md:bbs-signatures-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>BBS signatures sign an ordered list of messages and thus it is important to serialize your signing payload in this format.
Eg, in case of a credential with attributes in JSON format where each attribute is a key, convert the JSON to a list of
attributes and this conversion should be deterministic, meaning attributes should always end up in the same order. Following
is a conversion of a JSON credential with 4 attributes to a list where the values are placed in the alphabetical order of the keys:</p>
<p>Given JSON</p>
<pre><code class="json"><span class="hl-1">{</span><br/><span class="hl-1">  </span><span class="hl-6">&quot;ssn&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;12345678&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-6">&quot;fname&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;John&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-6">&quot;lname&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;Smith&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-6">&quot;city&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;NYC&quot;</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>Converted to list</p>
<pre><code><span class="hl-1">[</span><span class="hl-3">&quot;NYC&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;John&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;Smith&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;12345678&quot;</span><span class="hl-1">]</span>
</code><button>Copy</button></pre>

<p>Now each element of the above list must be converted to bytearrays, i.e. <code>Uint8Array</code> and the type of above list becomes <code>Uint8Array[]</code>.</p>
<a id="md:setup" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Setup<a href="#md:setup" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>Before messages can be signed, 2 things are needed:</p>
<ul>
<li>
<p><strong>Signature parameters</strong>: Public values, that can be created by anyone but must be known to the signer and verifier to sign and verify respectively. To create them, the number of messages (attributes) being signed must be known and the size of the parameters increases with the number. In the above example, number of attributes is 4. These parameters can be generated randomly or deterministically by using a publicly known label. It is advised to use the latter as it allows for extending/shrinking the same parameters when number of messages change.</p>
</li>
<li>
<p><strong>Keypair</strong>: To create and verify BBS signatures, the signer (issuer in case of a credential) needs to create a secret key to sign, public key to verify.</p>
<p>2 ways of generating signature parameters</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">BBSSignatureParams</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">messageCount</span><span class="hl-1"> = </span><span class="hl-9">4</span><span class="hl-1">;</span><br/><br/><span class="hl-4">// Randomly generated params</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">paramsRandom</span><span class="hl-1"> = </span><span class="hl-0">BBSSignatureParams</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-0">messageCount</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// the following function will be useful throughout the documentation</span><br/><span class="hl-7">function</span><span class="hl-1"> </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-0">message</span><span class="hl-1">: </span><span class="hl-10">string</span><span class="hl-1">): </span><span class="hl-10">Uint8Array</span><span class="hl-1"> {</span><br/><span class="hl-1">  </span><span class="hl-2">return</span><span class="hl-1"> </span><span class="hl-0">Uint8Array</span><span class="hl-1">.</span><span class="hl-5">from</span><span class="hl-1">(</span><span class="hl-0">Buffer</span><span class="hl-1">.</span><span class="hl-5">from</span><span class="hl-1">(</span><span class="hl-0">message</span><span class="hl-1">, </span><span class="hl-3">&#39;utf-8&#39;</span><span class="hl-1">));</span><br/><span class="hl-1">}</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">label</span><span class="hl-1"> = </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&quot;My sig params&quot;</span><span class="hl-1">);</span><br/><span class="hl-4">// Deterministically generated params</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">paramsDeterministc</span><span class="hl-1"> = </span><span class="hl-0">BBSSignatureParams</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-0">messageCount</span><span class="hl-1">, </span><span class="hl-0">label</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// Deterministic params can be extended if messageCount changes, say to 5 or 3</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">paramsDeterministc5</span><span class="hl-1"> = </span><span class="hl-0">paramsDeterministc</span><span class="hl-1">.</span><span class="hl-5">adapt</span><span class="hl-1">(</span><span class="hl-9">5</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">paramsDeterministc3</span><span class="hl-1"> = </span><span class="hl-0">paramsDeterministc</span><span class="hl-1">.</span><span class="hl-5">adapt</span><span class="hl-1">(</span><span class="hl-9">3</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Generating a keypair once signature parameters are created.</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">BBSKeypair</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">keypair</span><span class="hl-1"> = </span><span class="hl-0">BBSKeypair</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-0">paramsDeterministc</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sk</span><span class="hl-1"> = </span><span class="hl-0">keypair</span><span class="hl-1">.</span><span class="hl-0">secretKey</span><span class="hl-1">;</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">pk</span><span class="hl-1"> = </span><span class="hl-0">keypair</span><span class="hl-1">.</span><span class="hl-0">publicKey</span><span class="hl-1">;</span>
</code><button type="button">Copy</button></pre>

<a id="md:bytearray-messages" class="tsd-anchor"></a><h4 class="tsd-anchor-link">ByteArray messages<a href="#md:bytearray-messages" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>Each one of the messages should be a Uint8Array</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">messages</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1">[] = [</span><span class="hl-3">&quot;NYC&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;John&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;Smith&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;12345678&quot;</span><span class="hl-1">].</span><span class="hl-5">map</span><span class="hl-1">(</span><span class="hl-0">element</span><span class="hl-1"> </span><span class="hl-7">=&gt;</span><span class="hl-1"> </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-0">element</span><span class="hl-1">));</span>
</code><button type="button">Copy</button></pre>

</li>
</ul>
<a id="md:signing-and-verification" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Signing and verification<a href="#md:signing-and-verification" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>When the messages are arbitrary bytes, they need to be encoded to a field element (a number in certain range). You can either let the signing function encode it by passing
the <code>encode</code> argument as true to encode it using your own encoding function.</p>
<p>Letting the signing function encode</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">BBSSignature</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">// The signing function will encode bytes to a field element as true is passed</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sig</span><span class="hl-1"> = </span><span class="hl-0">BBSSignature</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-0">messages</span><span class="hl-1">, </span><span class="hl-0">sk</span><span class="hl-1">, </span><span class="hl-0">paramsDeterministc</span><span class="hl-1">, </span><span class="hl-7">true</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// As the messages are not encoded, pass true to the verification function to make it encode messages before verifying the signature.</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">result</span><span class="hl-1"> = </span><span class="hl-0">sig</span><span class="hl-1">.</span><span class="hl-5">verify</span><span class="hl-1">(</span><span class="hl-0">messages</span><span class="hl-1">, </span><span class="hl-0">pk</span><span class="hl-1">, </span><span class="hl-0">paramsDeterministc</span><span class="hl-1">, </span><span class="hl-7">true</span><span class="hl-1">);</span><br/><br/><span class="hl-0">console</span><span class="hl-1">.</span><span class="hl-5">assert</span><span class="hl-1">(</span><span class="hl-0">result</span><span class="hl-1">.</span><span class="hl-0">verified</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Passing pre-encoded messages to signing function</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">encodedMessages</span><span class="hl-1"> = [];</span><br/><br/><span class="hl-2">for</span><span class="hl-1"> (</span><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-0">i</span><span class="hl-1"> = </span><span class="hl-9">0</span><span class="hl-1">; </span><span class="hl-0">i</span><span class="hl-1"> &lt; </span><span class="hl-0">messages</span><span class="hl-1">.</span><span class="hl-0">length</span><span class="hl-1">; </span><span class="hl-0">i</span><span class="hl-1">++) {</span><br/><span class="hl-1">  </span><span class="hl-0">encodedMessages</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-5">generateFieldElementFromBytes</span><span class="hl-1">(</span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-0">i</span><span class="hl-1">]));</span><br/><span class="hl-1">}</span><br/><span class="hl-4">// The signing function will not encode as false is passed</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sig</span><span class="hl-1"> = </span><span class="hl-0">BBSSignature</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-0">encodedMessages</span><span class="hl-1">, </span><span class="hl-0">sk</span><span class="hl-1">, </span><span class="hl-0">params</span><span class="hl-1">, </span><span class="hl-7">false</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// As the messages are pre-encoded, pass false to the verification function to avoid encoding messages before verifying the signature.</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">result</span><span class="hl-1"> = </span><span class="hl-0">sig</span><span class="hl-1">.</span><span class="hl-5">verify</span><span class="hl-1">(</span><span class="hl-0">encodedMessages</span><span class="hl-1">, </span><span class="hl-0">pk</span><span class="hl-1">, </span><span class="hl-0">params</span><span class="hl-1">, </span><span class="hl-7">false</span><span class="hl-1">);</span><br/><span class="hl-0">console</span><span class="hl-1">.</span><span class="hl-5">assert</span><span class="hl-1">(</span><span class="hl-0">result</span><span class="hl-1">.</span><span class="hl-0">verified</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="md:proof-of-knowledge-of-signature" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Proof of knowledge of signature<a href="#md:proof-of-knowledge-of-signature" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>Proving and verifying knowledge of signature can be done with or without using the composite proof system but this doc will only describe using the composite proof system. For the other way, see tests <a href="media/scheme.spec.ts">here</a></p>
<p>The code for BBS lives <a href="./src/bbs/">here</a>.</p>
<a id="md:accumulators" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Accumulators<a href="#md:accumulators" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><a id="md:setup-1" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Setup<a href="#md:setup-1" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>Similar to BBS signatures, accumulators also have a setup phase where public parameters and keys are generated and these
public values need to be published. The accumulator manager's signing key is needed to update the accumulator or create
a witness and the public key is needed to verify the (non)membership. This document talks only about Positive accumulator,
for universal accumulator see the corresponding tests.</p>
<p>Similar to BBS, parameters can be generated randomly or deterministically.</p>
<pre><code class="ts"><span class="hl-4">// Randomly generated params</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">paramsRandom</span><span class="hl-1"> = </span><span class="hl-0">PositiveAccumulator</span><span class="hl-1">.</span><span class="hl-5">generateParams</span><span class="hl-1">();</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">label</span><span class="hl-1"> = </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&quot;My sig params&quot;</span><span class="hl-1">);</span><br/><span class="hl-4">// Deterministically generated params</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">params</span><span class="hl-1"> = </span><span class="hl-0">PositiveAccumulator</span><span class="hl-1">.</span><span class="hl-5">generateParams</span><span class="hl-1">(</span><span class="hl-0">label</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Generating a keypair once parameters are created.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">keypair</span><span class="hl-1"> = </span><span class="hl-0">PositiveAccumulator</span><span class="hl-1">.</span><span class="hl-5">generateKeypair</span><span class="hl-1">(</span><span class="hl-0">params</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Initialize the accumulator</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">accumulator</span><span class="hl-1"> = </span><span class="hl-0">PositiveAccumulator</span><span class="hl-1">.</span><span class="hl-5">initialize</span><span class="hl-1">(</span><span class="hl-0">params</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Care must be taken to not add duplicate elements in the accumulator or remove non-existent elements or creating witness of
non-existing elements. The accumulator itself cannot make such checks and thus this state must be tracked separately.
The interface for such a state is <a href="media/IAccumulatorState.ts">IAccumulatorState</a>. Its strongly recommended that
this state should be passed as an argument to the add, remove, and other functions that expect it. However, it's not mandatory
as the caller might have its own way of avoiding such issues. The tests below use an in-memory state <code>InMemoryState</code> which
implements <code>IAccumulatorState</code> interface.</p>
<a id="md:updating-the-accumulator" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Updating the accumulator<a href="#md:updating-the-accumulator" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>Elements can be added/removed individually or in a batch. Before adding an element, it must be encoded to a field element.
Encoding a positive integer can be done using <code>encodePositiveNumberAsAccumulatorMember</code>, arbitrary bytes can be encoded as
<code>encodeBytesAsAccumulatorMember</code>.</p>
<p>Adding 2 elements in the accumulator</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">InMemoryState</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">state</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">InMemoryState</span><span class="hl-1">();</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">e1</span><span class="hl-1"> = </span><span class="hl-0">Accumulator</span><span class="hl-1">.</span><span class="hl-5">encodePositiveNumberAsAccumulatorMember</span><span class="hl-1">(</span><span class="hl-9">101</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">bytes</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1"> = </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&quot;Some ID&quot;</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">e2</span><span class="hl-1"> = </span><span class="hl-0">Accumulator</span><span class="hl-1">.</span><span class="hl-5">encodeBytesAsAccumulatorMember</span><span class="hl-1">(</span><span class="hl-0">bytes</span><span class="hl-1">);</span><br/><br/><span class="hl-2">await</span><span class="hl-1"> </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">e1</span><span class="hl-1">, </span><span class="hl-0">keypair</span><span class="hl-1">.</span><span class="hl-0">secretKey</span><span class="hl-1">, </span><span class="hl-0">state</span><span class="hl-1">);</span><br/><span class="hl-2">await</span><span class="hl-1"> </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">e2</span><span class="hl-1">, </span><span class="hl-0">keypair</span><span class="hl-1">.</span><span class="hl-0">secretKey</span><span class="hl-1">, </span><span class="hl-0">state</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Removing an existing element</p>
<pre><code class="ts"><span class="hl-2">await</span><span class="hl-1"> </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-5">remove</span><span class="hl-1">(</span><span class="hl-0">e2</span><span class="hl-1">, </span><span class="hl-0">keypair</span><span class="hl-1">.</span><span class="hl-0">secretKey</span><span class="hl-1">, </span><span class="hl-0">state</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Adding multiple elements in a batch</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">e3</span><span class="hl-1"> = </span><span class="hl-0">Accumulator</span><span class="hl-1">.</span><span class="hl-5">encodePositiveNumberAsAccumulatorMember</span><span class="hl-1">(</span><span class="hl-9">103</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">e4</span><span class="hl-1"> = </span><span class="hl-0">Accumulator</span><span class="hl-1">.</span><span class="hl-5">encodePositiveNumberAsAccumulatorMember</span><span class="hl-1">(</span><span class="hl-9">104</span><span class="hl-1">);</span><br/><br/><span class="hl-2">await</span><span class="hl-1"> </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-5">addBatch</span><span class="hl-1">([</span><span class="hl-0">e3</span><span class="hl-1">, </span><span class="hl-0">e4</span><span class="hl-1">], </span><span class="hl-0">keypair</span><span class="hl-1">.</span><span class="hl-0">secretKey</span><span class="hl-1">, </span><span class="hl-0">state</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Adding and removing multiple elements in a batch</p>
<pre><code class="ts"><span class="hl-4">// Elements to add</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">additions</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1">[] = [</span><span class="hl-0">e1</span><span class="hl-1">, </span><span class="hl-0">e2</span><span class="hl-1">];</span><br/><span class="hl-4">// Elements to remove</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">removals</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1">[] = [</span><span class="hl-0">e3</span><span class="hl-1">, </span><span class="hl-0">e4</span><span class="hl-1">];</span><br/><br/><span class="hl-2">await</span><span class="hl-1"> </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-5">addRemoveBatches</span><span class="hl-1">(</span><span class="hl-0">additions</span><span class="hl-1">, </span><span class="hl-0">removals</span><span class="hl-1">, </span><span class="hl-0">keypair</span><span class="hl-1">.</span><span class="hl-0">secretKey</span><span class="hl-1">, </span><span class="hl-0">state</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="md:generating-witnesses" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Generating witnesses<a href="#md:generating-witnesses" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>Once an element is added to the accumulator by the manager, a witness is required to verify the membership.
Also required is the accumulator value when the witness was created, this value should be publicly available.</p>
<p>Generating a membership witness</p>
<pre><code class="ts"><span class="hl-4">// Note that the secret key is needed to create the witness</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witness</span><span class="hl-1"> = </span><span class="hl-2">await</span><span class="hl-1"> </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-5">membershipWitness</span><span class="hl-1">(</span><span class="hl-0">e4</span><span class="hl-1">, </span><span class="hl-0">keypair</span><span class="hl-1">.</span><span class="hl-0">secretKey</span><span class="hl-1">, </span><span class="hl-0">state</span><span class="hl-1">)</span>
</code><button type="button">Copy</button></pre>

<p>Verify the membership</p>
<pre><code class="ts"><span class="hl-4">// The accumulated value `accumulator.accumulated` is posted publicly</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">verifAccumulator</span><span class="hl-1"> = </span><span class="hl-0">PositiveAccumulator</span><span class="hl-1">.</span><span class="hl-5">fromAccumulated</span><span class="hl-1">(</span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-0">accumulated</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// Note that only public values needed to verify the membership</span><br/><span class="hl-0">console</span><span class="hl-1">.</span><span class="hl-5">assert</span><span class="hl-1">(</span><span class="hl-0">verifAccumulator</span><span class="hl-1">.</span><span class="hl-5">verifyMembershipWitness</span><span class="hl-1">(</span><span class="hl-0">e4</span><span class="hl-1">, </span><span class="hl-0">witness</span><span class="hl-1">, </span><span class="hl-0">pk</span><span class="hl-1">, </span><span class="hl-0">params</span><span class="hl-1">));</span>
</code><button type="button">Copy</button></pre>

<a id="md:updating-witnesses" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Updating witnesses<a href="#md:updating-witnesses" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>As the accumulator changes, the witness needs to be updated as well. The witness can be updated without the manager's
help if the updates (additions, removals) are known.</p>
<p>Update witness after an addition</p>
<pre><code class="ts"><span class="hl-4">// Say element e8 was added after the witness of e4 was created</span><br/><span class="hl-0">witness</span><span class="hl-1">.</span><span class="hl-5">updatePostAdd</span><span class="hl-1">(</span><span class="hl-0">e8</span><span class="hl-1">, </span><span class="hl-0">e4</span><span class="hl-1">, </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-0">accumulated</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Update witness after a removal</p>
<pre><code class="ts"><span class="hl-4">// Say element e1 was removed after the witness of e4 was created</span><br/><span class="hl-0">witness</span><span class="hl-1">.</span><span class="hl-5">updatePostRemove</span><span class="hl-1">(</span><span class="hl-0">e1</span><span class="hl-1">, </span><span class="hl-0">e4</span><span class="hl-1">, </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-0">accumulated</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The above method of updating the witness by going over each update is slow. The manager can make this process more efficient
for all members by publishing a <code>WitnessUpdatePublicInfo</code> built using the updates to the older accumulator. All members can then
use this public information to update their witnesses.</p>
<p>Manager creates <code>WitnessUpdatePublicInfo</code> and then updates the accumulator</p>
<pre><code class="ts"><span class="hl-4">// The current accumulated value is accumulator.accumulated</span><br/><br/><span class="hl-4">// Elements to add</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">additions</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1">[] = [...];</span><br/><span class="hl-4">// Elements to remove</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">removals</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1">[] = [...];</span><br/><br/><span class="hl-4">// This will be published along with `additions` and `removals`</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnessUpdateInfo</span><span class="hl-1"> = </span><span class="hl-0">WitnessUpdatePublicInfo</span><span class="hl-1">.</span><span class="hl-5">new</span><span class="hl-1">(</span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-0">accumulated</span><span class="hl-1">, </span><span class="hl-0">additions</span><span class="hl-1">, </span><span class="hl-0">removals</span><span class="hl-1">, </span><span class="hl-0">keypair</span><span class="hl-1">.</span><span class="hl-0">secretKey</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// Update the accumulator now</span><br/><span class="hl-2">await</span><span class="hl-1"> </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-5">addRemoveBatches</span><span class="hl-1">(</span><span class="hl-0">additions</span><span class="hl-1">, </span><span class="hl-0">removals</span><span class="hl-1">, </span><span class="hl-0">keypair</span><span class="hl-1">.</span><span class="hl-0">secretKey</span><span class="hl-1">, </span><span class="hl-0">state</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The member can now fetch the update information and update as</p>
<pre><code class="ts"><span class="hl-0">witness</span><span class="hl-1">.</span><span class="hl-5">updateUsingPublicInfoPostBatchUpdate</span><span class="hl-1">(</span><span class="hl-0">e4</span><span class="hl-1">, </span><span class="hl-0">additions</span><span class="hl-1">, </span><span class="hl-0">removals</span><span class="hl-1">, </span><span class="hl-0">witnessUpdInfo</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The member can update his witness given multiple such updates using <code>updateUsingPublicInfoPostMultipleBatchUpdates</code>. See the <a href="media/accumulator.spec.ts">tests</a> for examples.</p>
<a id="md:prefilled-accumulator" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Prefilled accumulator<a href="#md:prefilled-accumulator" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>The above workflow requires that after every addition to the accumulator, the new accumulator must be published along with witness
update info so that other members can update their witnesses. This is however expensive as the accumulator and update info might be posted
on the blockchain and also every existing member has to update its witness. One way to mitigate that is to create pre-filled
accumulators meaning that before publishing the accumulator the first time, the manager adds all the member ids in the accumulator.
This strategy assumes that member ids are either predictable like monotonically increasing numbers or the manager can internally keep
a map of random ids like UUIDs to a number. Now when the manager actually wants to allow a member to prove membership, he can
create a witness for that member but the accumulator value remains same and thus the witness for existing members also remain same.
It should be noted though that changing the accumulator value causes change in all existing witnesses and thus its better
to make a good estimate of the number of members during prefill stage. See <a href="media/prefilled-positive-accumulator.spec.ts">this test</a> for
a complete example using a positive accumulator.</p>
<p>Proof of membership and non-memberships can be done with or without using the composite proof system but this doc will only describe
using the composite proof system.</p>
<p>The code for accumulators lives <a href="./src/accumulator">here</a>.</p>
<a id="md:composite-proofs" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Composite proofs<a href="#md:composite-proofs" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><a id="md:terminology" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Terminology<a href="#md:terminology" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><ul>
<li><strong>Statement</strong> - The kind of proof that needs to be done and the public parameters needed to verify that proof. Eg. a BBS signature
statement contains public key of the signer, signature params, any revealed messages, etc. Each statement in a proof has a unique index.</li>
<li><strong>Witness</strong> - Private data that needs to be kept hidden from the verifier. This can be the messages/attributes that are not being disclosed,
the signature itself, the accumulator member, accumulator witness. Every witness corresponds to some <code>Statement</code>.</li>
<li><strong>WitnessRef</strong> - A witness might consist of several hidden data points, hidden attributes for example. To refer to each data
point uniquely, a pair of indices is used where the 1st item is the <code>Statement</code> index and 2nd item is index of that data point in the witness.</li>
<li><strong>MetaStatement</strong> - Describes a condition that must hold between witnesses of several statements or the same statement. Eg. to
express equality between attributes of 2 credentials, <code>MetaStatement</code> will refer to the <code>WitnessRef</code> of each attribute. This is
public information as well.</li>
<li><strong>SetupParam</strong> - Represents (public) setup parameters of different protocols.
This is helpful when the same setup parameter needs to be passed to several <code>Statement</code>s</li>
<li><strong>ProofSpec</strong> - This is the proof specification and its goal is to unambiguously define <strong>all</strong> what needs to be proven.
This is created from all <code>Statement</code>s, <code>MetaStatement</code>s and an optional context. Both prover and verifier should independently create this.
The prover uses the <code>ProofSpec</code> and all <code>Witness</code>es to create the proof and the verifier uses the<code>ProofSpec</code> to verify the proof.</li>
</ul>
<a id="md:examples" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Examples<a href="#md:examples" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><a id="md:selective-disclosure" class="tsd-anchor"></a><h5 class="tsd-anchor-link">Selective disclosure<a href="#md:selective-disclosure" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h5><p>A complete example is shown in this <a href="media/single-signature.spec.ts">test</a>.</p>
<p>Proving knowledge of 1 BBS signature over the attributes and only disclosing some attributes. Say there are 5 attributes in the
credential: SSN, first name, last name, email and city, and they are present in the attribute list in that order. The prover wants
to reveal his last name and city, but not any other attribute while proving that he possesses such a credential signed by the issuer.</p>
<pre><code class="ts"><span class="hl-4">// The attributes, [SSN, first name, last name, email, city]</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">messages</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1">[] = [</span><br/><span class="hl-1">  </span><span class="hl-3">&quot;230-95-4628&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;Harry&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;Potter&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;harry@potter.com&quot;</span><span class="hl-1">, </span><span class="hl-3">&quot;Little Whinging&quot;</span><br/><span class="hl-1">].</span><span class="hl-5">map</span><span class="hl-1">(</span><span class="hl-0">element</span><span class="hl-1"> </span><span class="hl-7">=&gt;</span><span class="hl-1"> </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-0">element</span><span class="hl-1">));</span><br/><br/><span class="hl-4">// Public values</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">params</span><span class="hl-1">: </span><span class="hl-10">BBSSignatureParams</span><span class="hl-1">;</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">pk</span><span class="hl-1">: </span><span class="hl-10">BBSPublicKey</span><span class="hl-1">;</span><br/><br/><span class="hl-4">// The signature</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sig</span><span class="hl-1">: </span><span class="hl-10">BBSSignature</span><span class="hl-1"> = ...;</span><br/><br/><span class="hl-4">// Prover prepares the attributes he wants to disclose, </span><br/><span class="hl-4">// i.e. attribute index 2 and 4 (indexing is 0-based), and the ones he wants to hide. </span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">revealedMsgIndices</span><span class="hl-1">: </span><span class="hl-10">Set</span><span class="hl-1">&lt;</span><span class="hl-10">number</span><span class="hl-1">&gt; = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Set</span><span class="hl-1">();</span><br/><span class="hl-0">revealedMsgIndices</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-9">2</span><span class="hl-1">);</span><br/><span class="hl-0">revealedMsgIndices</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-9">4</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// revealedMsgs are the attributes disclosed to the verifier</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">revealedMsgs</span><span class="hl-1">: </span><span class="hl-10">Map</span><span class="hl-1">&lt;</span><span class="hl-10">number</span><span class="hl-1">, </span><span class="hl-10">Uint8Array</span><span class="hl-1">&gt; = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Map</span><span class="hl-1">();</span><br/><span class="hl-0">revealedMsgs</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-9">2</span><span class="hl-1">, </span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-9">2</span><span class="hl-1">]);</span><br/><span class="hl-0">revealedMsgs</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-9">4</span><span class="hl-1">, </span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-9">4</span><span class="hl-1">]);</span><br/><br/><span class="hl-4">// unrevealedMsgs are the attributes hidden from the verifier</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">unrevealedMsgs</span><span class="hl-1">: </span><span class="hl-10">Map</span><span class="hl-1">&lt;</span><span class="hl-10">number</span><span class="hl-1">, </span><span class="hl-10">Uint8Array</span><span class="hl-1">&gt; = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Map</span><span class="hl-1">();</span><br/><span class="hl-0">unrevealedMsgs</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-9">0</span><span class="hl-1">]);</span><br/><span class="hl-0">unrevealedMsgs</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-9">1</span><span class="hl-1">]);</span><br/><span class="hl-0">unrevealedMsgs</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-9">3</span><span class="hl-1">]);</span>
</code><button type="button">Copy</button></pre>

<p>Since there is only 1 kind of proof, i.e. the knowledge of a BBS signature and the signed attributes, there would be only 1 <code>Statement</code>.</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">Statement</span><span class="hl-1">, </span><span class="hl-0">Statements</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><br/><br/><span class="hl-4">// Create a BBS signature, true indicates that attributes/messages are arbitrary bytes and should be encoded first.</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement1</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureProverConstantTime</span><span class="hl-1">(</span><span class="hl-0">paramsDeterministc</span><span class="hl-1">, </span><span class="hl-0">revealedMsgs</span><span class="hl-1">, </span><span class="hl-7">true</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Statements</span><span class="hl-1">();</span><br/><span class="hl-0">statements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement1</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// Optional context of the proof, this can specify the reason why the proof was created or date of the proof, or self-attested attributes (as JSON string), etc.</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">context</span><span class="hl-1"> = </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&#39;some context&#39;</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Once it has been established what needs to be proven, <code>ProofSpec</code> needs to be created which represents all the requirements.
Both the prover and verifier should independently construct this <code>ProofSpec</code>. Note that there are no <code>MetaStatements</code> as there are no
other conditions on the witnesses and thus its empty.</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">ProofSpec</span><span class="hl-1">, </span><span class="hl-0">MetaStatements</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">ms</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">MetaStatements</span><span class="hl-1">();</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proofSpec</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">ProofSpec</span><span class="hl-1">(</span><span class="hl-0">statements</span><span class="hl-1">, </span><span class="hl-0">ms</span><span class="hl-1">, [], </span><span class="hl-0">context</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Prover creates <code>Witness</code> using the signature and hidden attributes</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">Witness</span><span class="hl-1">, </span><span class="hl-0">Witnesses</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witness1</span><span class="hl-1"> = </span><span class="hl-0">Witness</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureConstantTime</span><span class="hl-1">(</span><span class="hl-0">sig</span><span class="hl-1">, </span><span class="hl-0">unrevealedMsgs</span><span class="hl-1">, </span><span class="hl-7">true</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnesses</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Witnesses</span><span class="hl-1">();</span><br/><span class="hl-0">witnesses</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">witness1</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Prover now uses the <code>ProofSpec</code> to create the proof. To ensure that the prover is not replaying, i.e. reusing a proof created by someone else, the verifier can request the prover to include its provided nonce in the proof.</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">CompositeProof</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">nonce</span><span class="hl-1"> = </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&#39;a unique nonce given by verifier&#39;</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proof</span><span class="hl-1"> = </span><span class="hl-0">CompositeProof</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-0">proofSpec</span><span class="hl-1">, </span><span class="hl-0">witnesses</span><span class="hl-1">, </span><span class="hl-0">nonce</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Verifier can now verify this proof. Note that the verifier does not and must not receive <code>ProofSpec</code> from prover,<br>
it needs to generate on its own.<br>
Also, note the usage of <code>bbsSignatureVerifierConstantTime</code> instead.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement1</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureVerifierConstantTime</span><span class="hl-1">(</span><span class="hl-0">sigParams</span><span class="hl-1">, </span><span class="hl-0">keyPair</span><span class="hl-1">.</span><span class="hl-0">publicKey</span><span class="hl-1">, </span><span class="hl-0">revealedMsgs</span><span class="hl-1">, </span><span class="hl-7">true</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Statements</span><span class="hl-1">();</span><br/><span class="hl-0">statements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement1</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">context</span><span class="hl-1"> = </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&#39;some context&#39;</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">ms</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">MetaStatements</span><span class="hl-1">();</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">verifierProofSpec</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">ProofSpec</span><span class="hl-1">(</span><span class="hl-0">statements</span><span class="hl-1">, </span><span class="hl-0">ms</span><span class="hl-1">, [], </span><span class="hl-0">context</span><span class="hl-1">);</span><br/><br/><span class="hl-0">console</span><span class="hl-1">.</span><span class="hl-5">assert</span><span class="hl-1">(</span><span class="hl-0">proof</span><span class="hl-1">.</span><span class="hl-5">verify</span><span class="hl-1">(</span><span class="hl-0">verifierProofSpec</span><span class="hl-1">, </span><span class="hl-0">nonce</span><span class="hl-1">).</span><span class="hl-0">verified</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="md:bbs-signatures-over-null-valued-messages" class="tsd-anchor"></a><h5 class="tsd-anchor-link">BBS signatures over null-valued messages<a href="#md:bbs-signatures-over-null-valued-messages" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h5><p>The examples above assumed all messages have values in them. However, in some cases, one or more attributes will be null within the credential.<br>
An example in which some of the messages correspond to attributes with null values (e.g. N/A) is a education qualification credential of a person. Someone with a highschool-level education will
have N/A for attributes like university name, major, etc.</p>
<p>One way to deal with this is to decide on some sentinel value like 0 or 'N/A' for all the null attributes
and disclose those values to the verifier.<br>
Another is to have a certain attribute (e.g. first message) in the credential specify which attribute
indices are null and always reveal this attribute.<br>
A complete example of the latter is shown in this
<a href="media/variable-number-of-messages.spec.ts">test</a>.</p>
<a id="md:multiple-bbs-signatures" class="tsd-anchor"></a><h5 class="tsd-anchor-link">Multiple BBS signatures<a href="#md:multiple-bbs-signatures" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h5><p>A complete example is shown in this <a href="tests/composite-proofs/many-bbs-signatures.spec.ts">test</a>.</p>
<p>Proving knowledge of 2 BBS signatures over the attributes and only disclosing some attribute and proving equality of 1 attribute
without disclosing it. Say there are 2 credentials and hence 2 BBS signatures. One credential has 5 attributes: SSN, first name,
last name, email and city and the other has 6 attributes name, email, city, employer, employee id and SSN and in that order.
The prover wants to prove that he has those 2 credentials, reveal his employer name and prove that SSN in both credentials is
the same without revealing the SSN.</p>
<pre><code class="ts"><span class="hl-4">// The attributes from 1st credential, [SSN, first name, last name, email, city]</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">messages1</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1">[] = [...];</span><br/><span class="hl-4">// The attributes from 2nd credential, [name, email, city, employer, employee id, SSN]</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">messages2</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1">[] = [...];</span><br/><br/><span class="hl-4">// Public values for 1st issuer</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">parasm1</span><span class="hl-1">: </span><span class="hl-10">BBSSignatureParams</span><span class="hl-1">;</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">pk1</span><span class="hl-1">: </span><span class="hl-10">BBSPublicKey</span><span class="hl-1">;</span><br/><br/><span class="hl-4">// Public values for 2nd issuer</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">parasm2</span><span class="hl-1">: </span><span class="hl-10">BBSSignatureParams</span><span class="hl-1">;</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">pk2</span><span class="hl-1">: </span><span class="hl-10">BBSPublicKey</span><span class="hl-1">;</span><br/><br/><span class="hl-4">// The signature from 1st credential</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sig1</span><span class="hl-1">: </span><span class="hl-10">BBSSignature</span><span class="hl-1"> = ...;</span><br/><br/><span class="hl-4">// The signature from 2nd credential</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sig2</span><span class="hl-1">: </span><span class="hl-10">BBSSignature</span><span class="hl-1"> = ...;</span>
</code><button type="button">Copy</button></pre>

<p>Since the prover is proving possession of 2 BBS signatures, there will be 2 <code>Statement</code>s. Also, for the 2nd signature prover is
revealing <em>employer</em> attribute, which is at index 3.</p>
<pre><code class="ts"><span class="hl-4">// Statement for signature of 1st signer, not revealing any messages to the verifier</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement1</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureProverConstantTime</span><span class="hl-1">(</span><span class="hl-0">params1</span><span class="hl-1">, </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Map</span><span class="hl-1">(), </span><span class="hl-7">true</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// Statement for signature of 2nd signer, revealing 1 message to the verifier</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">revealedMsgIndices</span><span class="hl-1">: </span><span class="hl-10">Set</span><span class="hl-1">&lt;</span><span class="hl-10">number</span><span class="hl-1">&gt; = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Set</span><span class="hl-1">();</span><br/><span class="hl-0">revealedMsgIndices</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-9">3</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">revealedMsgs</span><span class="hl-1">: </span><span class="hl-10">Map</span><span class="hl-1">&lt;</span><span class="hl-10">number</span><span class="hl-1">, </span><span class="hl-10">Uint8Array</span><span class="hl-1">&gt; = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Map</span><span class="hl-1">();</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">unrevealedMsgs2</span><span class="hl-1">: </span><span class="hl-10">Map</span><span class="hl-1">&lt;</span><span class="hl-10">number</span><span class="hl-1">, </span><span class="hl-10">Uint8Array</span><span class="hl-1">&gt; = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Map</span><span class="hl-1">();</span><br/><span class="hl-2">for</span><span class="hl-1"> (</span><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-0">i</span><span class="hl-1"> = </span><span class="hl-9">0</span><span class="hl-1">; </span><span class="hl-0">i</span><span class="hl-1"> &lt; </span><span class="hl-0">messageCount2</span><span class="hl-1">; </span><span class="hl-0">i</span><span class="hl-1">++) {</span><br/><span class="hl-1">  </span><span class="hl-2">if</span><span class="hl-1"> (</span><span class="hl-0">revealedMsgIndices</span><span class="hl-1">.</span><span class="hl-5">has</span><span class="hl-1">(</span><span class="hl-0">i</span><span class="hl-1">)) {</span><br/><span class="hl-1">    </span><span class="hl-0">revealedMsgs</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-0">i</span><span class="hl-1">, </span><span class="hl-0">messages2</span><span class="hl-1">[</span><span class="hl-0">i</span><span class="hl-1">]);</span><br/><span class="hl-1">  } </span><span class="hl-2">else</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-0">unrevealedMsgs2</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-0">i</span><span class="hl-1">, </span><span class="hl-0">messages2</span><span class="hl-1">[</span><span class="hl-0">i</span><span class="hl-1">]);</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">}</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement2</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureProverConstantTime</span><span class="hl-1">(</span><span class="hl-0">params2</span><span class="hl-1">, </span><span class="hl-0">revealedMsgs</span><span class="hl-1">, </span><span class="hl-7">true</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// Collect all the statements</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Statements</span><span class="hl-1">();</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sId1</span><span class="hl-1"> = </span><span class="hl-0">statements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement1</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sId2</span><span class="hl-1"> = </span><span class="hl-0">statements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement2</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The prover has 2 prove that both credentials contain the same SSN which is same as saying for the 1st signature (1st <code>Statement</code>),
attribute at index 0 is equal to 2nd signature's (2nd <code>Statement</code>) attribute index 5. This requires the use of a <code>MetaStatement</code> to
express this condition, specifically <code>MetaStatement.witnessEquality</code> which takes the <code>WitnessRef</code> for each witness that needs to be
proven equal. <code>WitnessRef</code> for SSN in 1st signature is (0, 0) and in 2nd signature is (1, 5). Create a <code>WitnessEqualityMetaStatement</code> to express that.</p>
<pre><code class="ts"><span class="hl-4">// For proving equality of SSN, messages1[0] == messages2[5], specify using MetaStatement</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnessEq</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">WitnessEqualityMetaStatement</span><span class="hl-1">();</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-9">5</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">ms</span><span class="hl-1"> = </span><span class="hl-0">MetaStatement</span><span class="hl-1">.</span><span class="hl-5">witnessEquality</span><span class="hl-1">(</span><span class="hl-0">witnessEq</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">metaStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">MetaStatements</span><span class="hl-1">();</span><br/><span class="hl-0">metaStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">ms</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Incase equality of additional attribute also needs to be proven say email, then <code>WitnessEqualityMetaStatement</code> needs to be created
for the <code>WitnessRef</code> of email in both signatures.</p>
<pre><code class="ts"><span class="hl-4">// For proving equality of email, messages1[3] == messages2[1], specify using MetaStatement</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnessEq2</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">WitnessEqualityMetaStatement</span><span class="hl-1">();</span><br/><span class="hl-0">witnessEq2</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-0">sId1</span><span class="hl-1">, </span><span class="hl-9">3</span><span class="hl-1">);</span><br/><span class="hl-0">witnessEq2</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-0">sId2</span><span class="hl-1">, </span><span class="hl-9">1</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">ms2</span><span class="hl-1"> = </span><span class="hl-0">MetaStatement</span><span class="hl-1">.</span><span class="hl-5">witnessEquality</span><span class="hl-1">(</span><span class="hl-0">witnessEq2</span><span class="hl-1">);</span><br/><br/><span class="hl-0">metaStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">ms2</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Similar to before, once it has been established what needs to be proven, <code>ProofSpec</code> needs to be created with all <code>Statements</code>s and <code>MetaStatement</code>s.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proofSpec</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">ProofSpec</span><span class="hl-1">(</span><span class="hl-0">statements</span><span class="hl-1">, </span><span class="hl-0">metaStatements</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The prover creates the witnesses with both signatures and messages that he is hiding from the verifier</p>
<pre><code class="ts"><span class="hl-4">// Using the messages and signature from 1st signer</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">unrevealedMsgs1</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Map</span><span class="hl-1">(</span><span class="hl-0">messages1</span><span class="hl-1">.</span><span class="hl-5">map</span><span class="hl-1">((</span><span class="hl-0">m</span><span class="hl-1">, </span><span class="hl-0">i</span><span class="hl-1">) </span><span class="hl-7">=&gt;</span><span class="hl-1"> [</span><span class="hl-0">i</span><span class="hl-1">, </span><span class="hl-0">m</span><span class="hl-1">]));</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witness1</span><span class="hl-1"> = </span><span class="hl-0">Witness</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureConstantTime</span><span class="hl-1">(</span><span class="hl-0">sig1</span><span class="hl-1">, </span><span class="hl-0">unrevealedMsgs1</span><span class="hl-1">, </span><span class="hl-7">true</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// Using the messages and signature from 2nd signer</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witness2</span><span class="hl-1"> = </span><span class="hl-0">Witness</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureConstantTime</span><span class="hl-1">(</span><span class="hl-0">sig2</span><span class="hl-1">, </span><span class="hl-0">unrevealedMsgs2</span><span class="hl-1">, </span><span class="hl-7">true</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnesses</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Witnesses</span><span class="hl-1">();</span><br/><span class="hl-0">witnesses</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">witness1</span><span class="hl-1">);</span><br/><span class="hl-0">witnesses</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">witness2</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proof</span><span class="hl-1"> = </span><span class="hl-0">CompositeProof</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-0">proofSpec</span><span class="hl-1">, </span><span class="hl-0">witnesses</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Verifier verifies the proof.</p>
<pre><code class="ts"><span class="hl-0">console</span><span class="hl-1">.</span><span class="hl-5">assert</span><span class="hl-1">(</span><span class="hl-0">proof</span><span class="hl-1">.</span><span class="hl-5">verify</span><span class="hl-1">(</span><span class="hl-0">proofSpec</span><span class="hl-1">).</span><span class="hl-0">verified</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="md:bbs-signature-together-with-accumulator-membership" class="tsd-anchor"></a><h5 class="tsd-anchor-link">BBS signature together with accumulator membership<a href="#md:bbs-signature-together-with-accumulator-membership" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h5><p>Say a prover has a credential where one of the attribute is added to an accumulator. The prover wants to prove that his attribute is a
member of the accumulator without revealing the attribute itself. Say the attributes are SSN, first name, last name, email and
user-id and the prover wants to prove that the user-id is present in the accumulator without revealing it to the verifier.</p>
<pre><code class="ts"><span class="hl-4">// The attributes, [SSN, first name, last name, email, user-id]</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">messages</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1">[] = [...];</span>
</code><button type="button">Copy</button></pre>

<p>Because the attributes for accumulator and BBS signatures are encoded differently, attributes are pre-encoded.</p>
<pre><code class="ts"><span class="hl-4">// Encode messages for signing as well as adding to the accumulator</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">encodedMessages</span><span class="hl-1"> = [];</span><br/><span class="hl-2">for</span><span class="hl-1"> (</span><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-0">i</span><span class="hl-1"> = </span><span class="hl-9">0</span><span class="hl-1">; </span><span class="hl-0">i</span><span class="hl-1"> &lt; </span><span class="hl-0">messageCount</span><span class="hl-1">; </span><span class="hl-0">i</span><span class="hl-1">++) {</span><br/><span class="hl-1">  </span><span class="hl-2">if</span><span class="hl-1"> (</span><span class="hl-0">i</span><span class="hl-1"> === </span><span class="hl-0">messageCount</span><span class="hl-1">-</span><span class="hl-9">1</span><span class="hl-1">) {</span><br/><span class="hl-1">    </span><span class="hl-4">// Last one, i.e. user id is added to the accumulator so encode accordingly</span><br/><span class="hl-1">    </span><span class="hl-0">encodedMessages</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-0">Accumulator</span><span class="hl-1">.</span><span class="hl-5">encodeBytesAsAccumulatorMember</span><span class="hl-1">(</span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-0">i</span><span class="hl-1">]));</span><br/><span class="hl-1">  } </span><span class="hl-2">else</span><span class="hl-1"> {</span><br/><span class="hl-1">    </span><span class="hl-0">encodedMessages</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-0">Signature</span><span class="hl-1">.</span><span class="hl-5">encodeMessageForSigning</span><span class="hl-1">(</span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-0">i</span><span class="hl-1">]));</span><br/><span class="hl-1">  }</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p>Both signer and accumulator manager will have public params and their secret keys</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sigParams</span><span class="hl-1"> = </span><span class="hl-0">BBSSignatureParams</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-9">5</span><span class="hl-1">, </span><span class="hl-0">label</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// Signers keys</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sigSk</span><span class="hl-1">: </span><span class="hl-10">BBSPlusSecretKey</span><span class="hl-1"> = ...;</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sigPk</span><span class="hl-1">: </span><span class="hl-10">BBSPublicKey</span><span class="hl-1"> = ...;</span><br/><br/><span class="hl-4">// Accumulator manager&#39;s params, keys and state</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">accumParams</span><span class="hl-1"> = </span><span class="hl-0">PositiveAccumulator</span><span class="hl-1">.</span><span class="hl-5">generateParams</span><span class="hl-1">(</span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&#39;Accumulator params&#39;</span><span class="hl-1">));</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">accumKeypair</span><span class="hl-1"> = </span><span class="hl-0">PositiveAccumulator</span><span class="hl-1">.</span><span class="hl-5">generateKeypair</span><span class="hl-1">(</span><span class="hl-0">accumParams</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">accumulator</span><span class="hl-1"> = </span><span class="hl-0">PositiveAccumulator</span><span class="hl-1">.</span><span class="hl-5">initialize</span><span class="hl-1">(</span><span class="hl-0">accumParams</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">state</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">InMemoryState</span><span class="hl-1">();</span>
</code><button type="button">Copy</button></pre>

<p>Signer signs the credential and accumulator manager adds the attribute to the credential and sends the witness to the prover</p>
<pre><code class="ts"><span class="hl-4">// Signer signs the message</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sig</span><span class="hl-1">: </span><span class="hl-10">BBSSignature</span><span class="hl-1"> = ...;</span><br/><br/><span class="hl-4">// user-id is at index 4 is the message list</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">userIdIdx</span><span class="hl-1"> = </span><span class="hl-9">4</span><span class="hl-1">;</span><br/><span class="hl-2">await</span><span class="hl-1"> </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">encodedMessages</span><span class="hl-1">[</span><span class="hl-0">userIdIdx</span><span class="hl-1">], </span><span class="hl-0">accumKeypair</span><span class="hl-1">.</span><span class="hl-0">secret_key</span><span class="hl-1">, </span><span class="hl-0">state</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">accumWitness</span><span class="hl-1"> = </span><span class="hl-2">await</span><span class="hl-1"> </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-5">membershipWitness</span><span class="hl-1">(</span><span class="hl-0">encodedMessages</span><span class="hl-1">[</span><span class="hl-0">userIdIdx</span><span class="hl-1">], </span><span class="hl-0">accumKeypair</span><span class="hl-1">.</span><span class="hl-0">secret_key</span><span class="hl-1">, </span><span class="hl-0">state</span><span class="hl-1">)</span>
</code><button type="button">Copy</button></pre>

<p>To prove accumulator membership in zero-knowledge, the prover and verifier agree on set of public parameters called the <code>ProvingKey</code>.
This is not specific to the accumulator and can be reused for any number of accumulators. Also a prover might use different
proving keys when interacting with different verifiers. Its recommended generating the proving key deterministically by passing a label.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">provingKey</span><span class="hl-1"> = </span><span class="hl-0">Accumulator</span><span class="hl-1">.</span><span class="hl-5">generateMembershipProvingKey</span><span class="hl-1">(</span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&#39;Our proving key&#39;</span><span class="hl-1">));</span>
</code><button type="button">Copy</button></pre>

<p>The prover needs to prove 2 <code>Statement</code>s, knowledge of BBS signature and knowledge of accumulator member and corresponding witness.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement1</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureProverConstantTime</span><span class="hl-1">(</span><span class="hl-0">sigParams</span><span class="hl-1">, </span><span class="hl-0">revealedMsgs</span><span class="hl-1">, </span><span class="hl-7">false</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement2</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">accumulatorMembership</span><span class="hl-1">(</span><span class="hl-0">accumParams</span><span class="hl-1">, </span><span class="hl-0">accumKeypair</span><span class="hl-1">.</span><span class="hl-0">public_key</span><span class="hl-1">, </span><span class="hl-0">provingKey</span><span class="hl-1">, </span><span class="hl-0">accumulator</span><span class="hl-1">.</span><span class="hl-0">accumulated</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Statements</span><span class="hl-1">();</span><br/><span class="hl-0">statements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement1</span><span class="hl-1">);</span><br/><span class="hl-0">statements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement2</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The prover also needs to prove that the accumulator member is same as the credential attribute at index 4, the user id.
The <code>WitnessRef</code> of the accumulator member is (1, 0) as index of membership <code>Statement</code> is 1 and index of member is always 0.</p>
<pre><code class="ts"><span class="hl-4">// The last message in the signature is same as the accumulator member</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnessEq</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">WitnessEqualityMetaStatement</span><span class="hl-1">();</span><br/><span class="hl-4">// Witness ref for last message in the signature</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-0">userIdIdx</span><span class="hl-1">);</span><br/><span class="hl-4">// Witness ref for accumulator member</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">ms</span><span class="hl-1"> = </span><span class="hl-0">MetaStatement</span><span class="hl-1">.</span><span class="hl-5">witnessEquality</span><span class="hl-1">(</span><span class="hl-0">witnessEq</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">metaStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">MetaStatements</span><span class="hl-1">();</span><br/><span class="hl-0">metaStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">ms</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proofSpec</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">ProofSpec</span><span class="hl-1">(</span><span class="hl-0">statements</span><span class="hl-1">, </span><span class="hl-0">metaStatements</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The prover creates <code>Witness</code>es for all statements and then creates the proof. The <code>Witness</code> for <code>Statement.accumulatorMembership</code> contains
the member and the accumulator witness.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witness1</span><span class="hl-1"> = </span><span class="hl-0">Witness</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureConstantTime</span><span class="hl-1">(</span><span class="hl-0">sig</span><span class="hl-1">, </span><span class="hl-0">unrevealedMsgs</span><span class="hl-1">, </span><span class="hl-7">false</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witness2</span><span class="hl-1"> = </span><span class="hl-0">Witness</span><span class="hl-1">.</span><span class="hl-5">accumulatorMembership</span><span class="hl-1">(</span><span class="hl-0">encodedMessages</span><span class="hl-1">[</span><span class="hl-0">userIdIdx</span><span class="hl-1">], </span><span class="hl-0">accumWitness</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnesses</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Witnesses</span><span class="hl-1">();</span><br/><span class="hl-0">witnesses</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">witness1</span><span class="hl-1">);</span><br/><span class="hl-0">witnesses</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">witness2</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proof</span><span class="hl-1"> = </span><span class="hl-0">CompositeProof</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-0">proofSpec</span><span class="hl-1">, </span><span class="hl-0">witnesses</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="md:getting-a-blind-signature-example-applies-to-bbs" class="tsd-anchor"></a><h5 class="tsd-anchor-link">Getting a blind signature (Example applies to BBS+)<a href="#md:getting-a-blind-signature-example-applies-to-bbs" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h5><p>Disclaimer: With BBS, there is no blinding (the commitment is computationally hiding, though it can be made perfectly hiding by adding a dummy attribute). However, it can be easily achieved with BBS+.
A complete example is shown in this <a href="media/blind-signature.spec.ts">test</a>.</p>
<p>A signature is blind when the signer is not aware of the message (or a part of the message) that he is signing, thus the signer is blind.
Blind signature in credential is used when the holder does not want the signer to learn some attribute, eg. one of the credential
attribute is a secret key and the holder does not want the signer to learn the secret key. Here the user creates a commitment to
the &quot;blinded&quot;, i.e. hidden attributes to convince the signer that he is only hiding the certain attribute(s). Eg if a credential has 5
attributes secret1, name, secret2, email, city and the user wants to hide secret1 and secret2 from the signer, the signer wants to
be sure that the user is indeed hiding attributes at index 0 and 2, not others. The prover uses the composite proof system to
prove that he knows that the commitment contains those 2 attributes</p>
<pre><code class="ts"><span class="hl-4">// Messages are secret1, name, secret2, email, city</span><br/><br/><span class="hl-4">// Signature params for 5 attributes</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sigParams</span><span class="hl-1"> = </span><span class="hl-0">BBSPlusSignatureParamsG1</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-9">5</span><span class="hl-1">, </span><span class="hl-0">label</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// Prepare messages that will be blinded (hidden) and known to signer</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">blindedMessages</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Map</span><span class="hl-1">();</span><br/><br/><span class="hl-4">// User wants to hide messages at indices 0 and 2 from signer</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">blindedIndices</span><span class="hl-1">: </span><span class="hl-10">number</span><span class="hl-1">[] = [];</span><br/><span class="hl-0">blindedIndices</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-0">blindedMessages</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&#39;my-secret&#39;</span><span class="hl-1">));</span><br/><span class="hl-0">blindedIndices</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-9">2</span><span class="hl-1">);</span><br/><span class="hl-0">blindedMessages</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-9">2</span><span class="hl-1">, </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&#39;my-another-secret&#39;</span><span class="hl-1">));</span>
</code><button type="button">Copy</button></pre>

<p>The signature requester, prover in this case, creates a blind signature request. In addition to the request, it also returns
randomness <code>blinding</code> that goes into the commitment. This randomness is later used</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">BBSPlusBlindSignatureG1</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">// Blind signature request will contain a commitment, </span><br/><span class="hl-7">const</span><span class="hl-1"> [</span><span class="hl-8">blinding</span><span class="hl-1">, </span><span class="hl-8">request</span><span class="hl-1">] = </span><span class="hl-0">BBSPlusBlindSignatureG1</span><span class="hl-1">.</span><span class="hl-5">generateRequest</span><span class="hl-1">(</span><span class="hl-0">blindedMessages</span><span class="hl-1">, </span><span class="hl-0">params</span><span class="hl-1">, </span><span class="hl-7">true</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The proof needs to be over only 1 <code>Statement</code>, the statement proving knowledge of the committed attributes in the commitment.
To create the commitment, a commitment key (public values) needs to be created from the signature params</p>
<pre><code class="ts"><span class="hl-4">// Take parts of the sig params corresponding to the blinded messages and create the commitment key commKey</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">commKey</span><span class="hl-1"> = </span><span class="hl-0">params</span><span class="hl-1">.</span><span class="hl-5">getParamsForIndices</span><span class="hl-1">(</span><span class="hl-0">request</span><span class="hl-1">.</span><span class="hl-0">blindedIndices</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement1</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">pedersenCommitmentG1</span><span class="hl-1">(</span><span class="hl-0">bases</span><span class="hl-1">, </span><span class="hl-0">request</span><span class="hl-1">.</span><span class="hl-0">commitment</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Statements</span><span class="hl-1">();</span><br/><span class="hl-0">statements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement1</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proofSpec</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">ProofSpec</span><span class="hl-1">(</span><span class="hl-0">statements</span><span class="hl-1">, </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">MetaStatements</span><span class="hl-1">());</span>
</code><button type="button">Copy</button></pre>

<p>Now the prover creates witness for the commitment <code>Statement</code> using the randomness and the hidden attributes.</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">getBBSWitnessForBlindSigRequest</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witness1</span><span class="hl-1"> = </span><span class="hl-5">getBBSWitnessForBlindSigRequest</span><span class="hl-1">(</span><span class="hl-0">blindedMessages</span><span class="hl-1">)</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnesses</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Witnesses</span><span class="hl-1">();</span><br/><span class="hl-0">witnesses</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">witness1</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proof</span><span class="hl-1"> = </span><span class="hl-0">CompositeProof</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-0">proofSpec</span><span class="hl-1">, </span><span class="hl-0">witnesses</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Signer now verifies the proof. Note that the signer independently creates the <code>ProofSpec</code> as he knows which attributes are being
hidden from him. If the proof is correct, signer creates a blind signature using the known attributes and the commitment
and sends to the prover.</p>
<pre><code class="ts"><span class="hl-0">console</span><span class="hl-1">.</span><span class="hl-5">assert</span><span class="hl-1">(</span><span class="hl-0">proof</span><span class="hl-1">.</span><span class="hl-5">verify</span><span class="hl-1">(</span><span class="hl-0">proofSpec</span><span class="hl-1">).</span><span class="hl-0">verified</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// Signer is convinced that user knows the opening to the commitment</span><br/><br/><span class="hl-4">// Signer creates a blind signature with these revealed messages and the commitment.</span><br/><span class="hl-0">revealedMessages</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&#39;John Smith&#39;</span><span class="hl-1">));</span><br/><span class="hl-0">revealedMessages</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-9">3</span><span class="hl-1">, </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&#39;john.smith@emample.com&#39;</span><span class="hl-1">));</span><br/><span class="hl-0">revealedMessages</span><span class="hl-1">.</span><span class="hl-5">set</span><span class="hl-1">(</span><span class="hl-9">4</span><span class="hl-1">, </span><span class="hl-5">stringToBytes</span><span class="hl-1">(</span><span class="hl-3">&#39;New York&#39;</span><span class="hl-1">));</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">blindSig</span><span class="hl-1"> = </span><span class="hl-0">BBSPlusBlindSignatureG1</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(</span><span class="hl-0">request</span><span class="hl-1">.</span><span class="hl-0">commitment</span><span class="hl-1">, </span><span class="hl-0">revealedMessages</span><span class="hl-1">, </span><span class="hl-0">sk</span><span class="hl-1">, </span><span class="hl-0">params</span><span class="hl-1">, </span><span class="hl-7">true</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The prover can now &quot;unblind&quot; the signature meaning he can convert a blind signature into a regular BBS signature
which he can use in proof as shown in examples above</p>
<pre><code class="ts"><span class="hl-4">// Unbling the signature from the randomness of the commitment.</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">sig</span><span class="hl-1"> = </span><span class="hl-0">blindSig</span><span class="hl-1">.</span><span class="hl-5">unblind</span><span class="hl-1">(</span><span class="hl-0">blinding</span><span class="hl-1">);</span><br/><br/><span class="hl-4">// Combine blinded and revealed messages in an array</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">messages</span><span class="hl-1"> = </span><span class="hl-5">Array</span><span class="hl-1">(</span><span class="hl-0">blindedMessages</span><span class="hl-1">.</span><span class="hl-0">size</span><span class="hl-1"> + </span><span class="hl-0">revealedMessages</span><span class="hl-1">.</span><span class="hl-0">size</span><span class="hl-1">);</span><br/><span class="hl-2">for</span><span class="hl-1"> (</span><span class="hl-7">const</span><span class="hl-1"> [</span><span class="hl-8">i</span><span class="hl-1">, </span><span class="hl-8">m</span><span class="hl-1">] </span><span class="hl-7">of</span><span class="hl-1"> </span><span class="hl-0">blindedMessages</span><span class="hl-1">.</span><span class="hl-5">entries</span><span class="hl-1">()) {</span><br/><span class="hl-1">  </span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-0">i</span><span class="hl-1">] = </span><span class="hl-0">m</span><span class="hl-1">;</span><br/><span class="hl-1">}</span><br/><span class="hl-2">for</span><span class="hl-1"> (</span><span class="hl-7">const</span><span class="hl-1"> [</span><span class="hl-8">i</span><span class="hl-1">, </span><span class="hl-8">m</span><span class="hl-1">] </span><span class="hl-7">of</span><span class="hl-1"> </span><span class="hl-0">revealedMessages</span><span class="hl-1">.</span><span class="hl-5">entries</span><span class="hl-1">()) {</span><br/><span class="hl-1">  </span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-0">i</span><span class="hl-1">] = </span><span class="hl-0">m</span><span class="hl-1">;</span><br/><span class="hl-1">}</span><br/><br/><span class="hl-4">// Signature can be verified</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">result</span><span class="hl-1"> = </span><span class="hl-0">sig</span><span class="hl-1">.</span><span class="hl-5">verify</span><span class="hl-1">(</span><span class="hl-0">messages</span><span class="hl-1">, </span><span class="hl-0">pk</span><span class="hl-1">, </span><span class="hl-0">params</span><span class="hl-1">, </span><span class="hl-7">true</span><span class="hl-1">);</span><br/><span class="hl-0">console</span><span class="hl-1">.</span><span class="hl-5">assert</span><span class="hl-1">(</span><span class="hl-0">result</span><span class="hl-1">.</span><span class="hl-0">verified</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="md:pseudonyms" class="tsd-anchor"></a><h5 class="tsd-anchor-link">Pseudonyms<a href="#md:pseudonyms" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h5><p>A pseudonym is meant to be used as a unique identifier. It can be considered as a public key where the creator of the
pseudonym has the secret key, and it can prove the knowledge of this secret key. A pseudonym can also be bound to multiple
attributes from multiple credentials. This concept was introduced in <a href="https://link.springer.com/book/10.1007/978-3-319-14439-9" target="_blank" class="external">Attribute-based Credentials for Trust</a>.</p>
<p><strong>Motivation</strong>: Proving knowledge of BBS signatures is unlinkable meaning the verifier cannot link to 2 proofs presented from the same
credential (signature). But this might not always be desirable for the verifier and the prover might agree to being linked for any
proofs that he creates for that particular verifier without revealing any attribute of the credential.<br>
A verifier wants to attach a unique identifier to a prover without either learning anything unintended (by prover)
from the prover's signature nor can that unique identifier be used by other verifiers to identify the prover,
eg. a seller (as a verifier) should be able to identify repeat customers (prover) by using a unique identifier, but
he should not be able to share that unique identifier with other sellers using their own identifier for that prover.</p>
<p>Above is achieved by making the prover go through a one-time registration process with the verifier where the prover creates
a pseudonym and shares the pseudonym with the verifier. The prover on subsequent interactions share the pseudonym and
proof of knowledge of the pseudonym's secret key with the verifier. Thus, pseudonyms allow for verifier-local and opt-in linkability.</p>
<p>In the <a href="media/pseudonyms.spec.ts">test</a>, the credential has 4 attributes, SSN, first name,
last name and email and during registration, the prover creates many pseudonyms, for different verifiers, some are bound to attributes
and some not. See the test for more details.</p>
<a id="md:social-kyc" class="tsd-anchor"></a><h5 class="tsd-anchor-link">Social KYC<a href="#md:social-kyc" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h5><p>A social KYC (Know Your Customer) credential claims that the subject owns certain social media profile like a twitter profile
credential claims that a user owns the twitter profile with certain handle. Here the issuer of the credential must verify
the user's control of the profile. One way to achieve that is for the user to post a unique issuer supplied challenge string
on his profile, like tweeting it when requesting twitter profile credential. This makes the process 2-step, in step 1 user
requests the challenge from issuer and which he tweets and in step 2, he asks the issuer to check the tweet and issue him
a credential. An alternate approach is for the user to post a commitment to some random value on his profile and then request
a credential from the issuer by supplying a proof of knowledge of the opening (committed random value) of the commitment.
The issuer is convinced that no one else could know the opening of the commitment which was posted by the user. Note that
the user is proving knowledge of the committed value and not revealing it to the issuer because revealing the value will
allow the issuer to request a similar credential from some another issuer of it the revealed value is leaked then someone
else can impersonate the user.<br>
The <a href="media/social-kyc.spec.ts">test</a> shows a complete example.</p>
<p>The code for composite proof lives <a href="./src/composite-proof">here</a>. See the tests <a href="./tests/composite-proofs">here</a> for various scenarios.
For a more involved demo with multiple BBS signatures being used with accumulator and knowledge of signatures being proved
before requesting blind signatures, see <a href="media/demo.spec.ts">here</a>. This test paints a picture where before getting any credential,
a user has to prove possession of a credential and membership in an accumulator (except the 1st credential).</p>
<a id="md:verifiable-encryption-using-saver" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Verifiable encryption using SAVER<a href="#md:verifiable-encryption-using-saver" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Note: This section assumes you have read some of the previous examples on composite proof.</p>
<p>A complete example as a test is <a href="media/saver.spec.ts">here</a></p>
<p>Say a verifier wants the prover to encrypt an attribute from his credential for a 3rd party say a regulator. The verifier should be
able to check that the prover did encrypt a specific attribute from his credential and not some arbitrary value. Also, the verifier
should be able to check that the ciphertext is encrypted for the specific public key. This is achieved through verifiable
encryption and implemented using a protocol called <a href="https://eprint.iacr.org/2019/1270" target="_blank" class="external">SAVER</a>.<br>
For this, the decryptor needs to do a setup where it creates several parameters including encrytion key, decryption key,
SNARK proving key and verification key, etc. The decryptor then publishes the public parameters. In the snippet below,
<code>snarkPk</code>, <code>encryptionKey</code>, <code>decryptionKey</code> and <code>gens</code> are published.</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">SaverEncryptionGens</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">encGens</span><span class="hl-1"> = </span><span class="hl-0">SaverEncryptionGens</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">();</span><br/><span class="hl-7">const</span><span class="hl-1"> [</span><span class="hl-8">snarkPk</span><span class="hl-1">, </span><span class="hl-8">secretKey</span><span class="hl-1">, </span><span class="hl-8">encryptionKey</span><span class="hl-1">, </span><span class="hl-8">decryptionKey</span><span class="hl-1">] = </span><span class="hl-0">SaverDecryptor</span><span class="hl-1">.</span><span class="hl-5">setup</span><span class="hl-1">(</span><span class="hl-0">encGens</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p><code>SaverDecryptor.setup</code> above takes an optional parameter <code>chunkBitSize</code> which can make the encryption and proving faster (or slower)
while making decryption slower (or faster). Since encryption and proving are done more often, a higher default value of 16
is chosen for this parameter. Note that once parameters have been created with a certain value of <code>chunkBitSize</code>, the same value
should be used while encryption, decryption, proving and verification (as shown below).</p>
<a id="md:encoding-for-verifiable-encryption" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Encoding for verifiable encryption<a href="#md:encoding-for-verifiable-encryption" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>For signers (issuers of credentials), it's important to encode attributes that need to be verifiably encrypted using a reversible
encoding as the decryption might happen much later than the proof verification and thus the decryptor should be able to independently
recover the actual attributes. This situation is different from selective disclosure where the actual attributes are given to the
verifier who can then encode the attributes before verifying the proof. One such pair of functions are <code>Signature.reversibleEncodeStringForSigning</code>
and <code>Signature.reversibleDecodeStringForSigning</code> and you can see its use in the above-mentioned test. Theese conversions are abstracted in this <a href="./src/bbs-plus/encoder.ts">Encoders</a> class and you can see the usage
in <a href="media/saver.spec-1.ts">these tests</a> of the  <code>Encoder</code> initialized <a href="media/data-and-encoder.ts">here</a>.</p>
<p>For creating the proof of knowledge of the BBS signature and verifiably encrypting an attribute, the prover creates the following 2 statements.</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">SaverChunkedCommitmentKey</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">// Signer&#39;s parameters</span><br/><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-0">sigParams</span><span class="hl-1">: </span><span class="hl-10">BBSSignatureParams</span><span class="hl-1">, </span><span class="hl-0">sigPk</span><span class="hl-1">: </span><span class="hl-10">BBSPublicKey</span><span class="hl-1">, </span><span class="hl-0">sig</span><span class="hl-1">: </span><span class="hl-10">BBSSignature</span><span class="hl-1">;</span><br/><span class="hl-4">// Signed messages</span><br/><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-0">messages</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1">[];</span><br/><span class="hl-1">...</span><br/><span class="hl-1">...</span><br/><span class="hl-4">// The value used by decryptor during setup</span><br/><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-0">chunkBitSize</span><span class="hl-1"> = ...;</span><br/><span class="hl-1">...</span><br/><span class="hl-1">...</span><br/><span class="hl-4">// The following is either created by the verifier and is shared with the prover or created by the prover using a public bytes </span><br/><span class="hl-4">// as argument to `SaverChunkedCommitmentKey.generate`  </span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">gens</span><span class="hl-1"> = </span><span class="hl-0">SaverChunkedCommitmentKey</span><span class="hl-1">.</span><span class="hl-5">generate</span><span class="hl-1">(&lt;</span><span class="hl-10">some</span><span class="hl-1"> </span><span class="hl-10">public</span><span class="hl-1"> </span><span class="hl-10">bytes</span><span class="hl-1">&gt;);</span><br/><span class="hl-1">...</span><br/><span class="hl-1">...</span><br/><span class="hl-4">// Uncompressed form of `gens` created above</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">commKey</span><span class="hl-1"> = </span><span class="hl-0">gens</span><span class="hl-1">.</span><span class="hl-5">decompress</span><span class="hl-1">();</span><br/><span class="hl-4">// Uncompressed form of other parameters created by decryptor</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">saverEncGens</span><span class="hl-1"> = </span><span class="hl-0">encGens</span><span class="hl-1">.</span><span class="hl-5">decompress</span><span class="hl-1">();</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">saverEk</span><span class="hl-1"> = </span><span class="hl-0">encryptionKey</span><span class="hl-1">.</span><span class="hl-5">decompress</span><span class="hl-1">();</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">snarkProvingKey</span><span class="hl-1"> = </span><span class="hl-0">snarkPk</span><span class="hl-1">.</span><span class="hl-5">decompress</span><span class="hl-1">();</span><br/><span class="hl-1">...</span><br/><span class="hl-1">...</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement1</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureProverConstantTime</span><span class="hl-1">(</span><span class="hl-0">sigParams</span><span class="hl-1">, </span><span class="hl-0">revealedMsgs</span><span class="hl-1">, </span><span class="hl-7">false</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement2</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">saverProver</span><span class="hl-1">(</span><span class="hl-0">saverEncGens</span><span class="hl-1">, </span><span class="hl-0">commKey</span><span class="hl-1">, </span><span class="hl-0">saverEk</span><span class="hl-1">, </span><span class="hl-0">snarkProvingKey</span><span class="hl-1">, </span><span class="hl-0">chunkBitSize</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proverStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Statements</span><span class="hl-1">();</span><br/><span class="hl-0">proverStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement1</span><span class="hl-1">);</span><br/><span class="hl-0">proverStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement2</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p><code>statement1</code> is the for proving knowledge of a BBS signature as seen in previous examples. <code>statement2</code> is for proving the encryption of message from a
BBS signature. Some things to note about this statement.</p>
<ul>
<li>The statement is created using <code>Statement.saverProver</code> because it is being created by a prover. A verifier would have
used <code>Statement.saverVerifier</code> to create it and one of the arguments would be different (shown below).</li>
<li>The argument <code>saverEncGens</code> is the encryption generators created by decryptor. However, before they are passed to <code>Statement.saverProver</code>, the are uncompressed (ref. elliptic curve point compression) as shown in the above snippet. Uncompressing them doubles their size but makes them faster to work with. However, if you still want to use the compressed parameters use <code>Statement.saverProverFromCompressedParams</code></li>
<li><code>saverEk</code> is the encryption key created by the decryptor during <code>setup</code> but is uncompressed.</li>
<li><code>snarkProvingKey</code> is the proving key created by the decryptor during <code>setup</code> but is uncompressed.</li>
</ul>
<p>The prover then establishes the equality between the message in the BBS signature and the message being encrypted by using
<code>WitnessEqualityMetaStatement</code> as below. <code>encMsgIdx</code> is the index of the message being encrypted in the array of signed
messages under BBS, <code>messages</code>. For the second statement, there is only 1 witness, thus the index 0.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnessEq</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">WitnessEqualityMetaStatement</span><span class="hl-1">();</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-0">encMsgIdx</span><span class="hl-1">);</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">metaStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">MetaStatements</span><span class="hl-1">();</span><br/><span class="hl-0">metaStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">MetaStatement</span><span class="hl-1">.</span><span class="hl-5">witnessEquality</span><span class="hl-1">(</span><span class="hl-0">witnessEq</span><span class="hl-1">));</span>
</code><button type="button">Copy</button></pre>

<p>The prover then creates witness for both statements. The message <code>messages[encMsgIdx]</code> passed to <code>Witness.saver</code> is the
message being encrypted. <code>unrevealedMsgs</code> passed to <code>Witness.bbsSignatureConstantTime</code> is created from <code>messages</code> and consists of
messages not being revealed to the verifier.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witness1</span><span class="hl-1"> = </span><span class="hl-0">Witness</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureConstantTime</span><span class="hl-1">(</span><span class="hl-0">sig</span><span class="hl-1">, </span><span class="hl-0">unrevealedMsgs</span><span class="hl-1">, </span><span class="hl-7">false</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witness2</span><span class="hl-1"> = </span><span class="hl-0">Witness</span><span class="hl-1">.</span><span class="hl-5">saver</span><span class="hl-1">(</span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-0">encMsgIdx</span><span class="hl-1">]);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnesses</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Witnesses</span><span class="hl-1">();</span><br/><span class="hl-0">witnesses</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">witness1</span><span class="hl-1">);</span><br/><span class="hl-0">witnesses</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">witness2</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The prover then creates a proof specification using <code>QuasiProofSpec</code>. This is different from <code>ProofSpec</code> object seen in
previous examples as it does not call WASM to get a proof specification object and thus is more efficient.<br>
Now prover creates the proof using <code>CompositeProof.generateUsingQuasiProofSpec</code></p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">QuasiProofSpec</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proverProofSpec</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">QuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">proverStatements</span><span class="hl-1">, </span><span class="hl-0">metaStatements</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proof</span><span class="hl-1"> = </span><span class="hl-0">CompositeProof</span><span class="hl-1">.</span><span class="hl-5">generateUsingQuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">proverProofSpec</span><span class="hl-1">, </span><span class="hl-0">witnesses</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Similarly, the verifier also creates 2 statements and the same meta statement to verify the proof.</p>
<pre><code class="ts"><span class="hl-4">// Get the uncompressed verifying key from the compressed proving key.</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">snarkVerifyingKey</span><span class="hl-1"> = </span><span class="hl-0">snarkPk</span><span class="hl-1">.</span><span class="hl-5">getVerifyingKeyUncompressed</span><span class="hl-1">();</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement1</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureProverConstantTime</span><span class="hl-1">(</span><span class="hl-0">sigParams</span><span class="hl-1">, </span><span class="hl-0">revealedMsgs</span><span class="hl-1">, </span><span class="hl-7">false</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement2</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">saverVerifier</span><span class="hl-1">(</span><span class="hl-0">saverEncGens</span><span class="hl-1">, </span><span class="hl-0">commKey</span><span class="hl-1">, </span><span class="hl-0">saverEk</span><span class="hl-1">, </span><span class="hl-0">snarkVerifyingKey</span><span class="hl-1">, </span><span class="hl-0">chunkBitSize</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">verifierStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Statements</span><span class="hl-1">();</span><br/><span class="hl-0">verifierStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement1</span><span class="hl-1">);</span><br/><span class="hl-0">verifierStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement2</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnessEq</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">WitnessEqualityMetaStatement</span><span class="hl-1">();</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-0">encMsgIdx</span><span class="hl-1">);</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">metaStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">MetaStatements</span><span class="hl-1">();</span><br/><span class="hl-0">metaStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">MetaStatement</span><span class="hl-1">.</span><span class="hl-5">witnessEquality</span><span class="hl-1">(</span><span class="hl-0">witnessEq</span><span class="hl-1">));</span>
</code><button type="button">Copy</button></pre>

<p>The above has a few differences from the prover's statements:</p>
<ul>
<li>Instead of using <code>Statement.saverProver</code>, verifier uses <code>Statement.saverVerifier</code>.</li>
<li>Instead of proving key, verifier uses verifying key for the snark.</li>
</ul>
<p>The verifier now creates the proof specification and verifies the proof.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">verifierProofSpec</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">QuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">verifierStatements</span><span class="hl-1">, </span><span class="hl-0">metaStatements</span><span class="hl-1">);</span><br/><span class="hl-4">// result.verified should be true for the proof to be valid.</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">result</span><span class="hl-1"> = </span><span class="hl-0">proof</span><span class="hl-1">.</span><span class="hl-5">verifyUsingQuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">verifierProofSpec</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The verifier will now extract the ciphertext from the proof so that it can share that with the decryptor later. Here <code>1</code>
passed to <code>proof.getSaverCiphertext</code> is the index (0-based) of the statement in the list of statements being proven and the
statement from verifiable encryption was the 2nd one.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">ciphertext</span><span class="hl-1"> = </span><span class="hl-0">proof</span><span class="hl-1">.</span><span class="hl-5">getSaverCiphertext</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The decryptor can decrypt the ciphertext to get message that was encrypted.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">saverDk</span><span class="hl-1"> = </span><span class="hl-0">decryptionKey</span><span class="hl-1">.</span><span class="hl-5">decompress</span><span class="hl-1">();</span><br/><span class="hl-4">// decrypted.message is the message</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">decrypted</span><span class="hl-1"> = </span><span class="hl-0">SaverDecryptor</span><span class="hl-1">.</span><span class="hl-5">decryptCiphertext</span><span class="hl-1">(</span><span class="hl-0">ciphertext</span><span class="hl-1">, </span><span class="hl-0">saverSk</span><span class="hl-1">, </span><span class="hl-0">saverDk</span><span class="hl-1">, </span><span class="hl-0">snarkVerifyingKey</span><span class="hl-1">, </span><span class="hl-0">chunkBitSize</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Sometimes the verifier might want to know the decrypted message but might not trust that the decryptor to correctly tell
him the decrypted message. In this it can verify the decryption done by the decryptor as below</p>
<pre><code class="ts"><span class="hl-4">// result.verified should be true</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">result</span><span class="hl-1"> = </span><span class="hl-0">ciphertext</span><span class="hl-1">.</span><span class="hl-5">verifyDecryption</span><span class="hl-1">(</span><span class="hl-0">decrypted</span><span class="hl-1">, </span><span class="hl-0">saverDk</span><span class="hl-1">, </span><span class="hl-0">snarkVerifyingKey</span><span class="hl-1">, </span><span class="hl-0">saverEncGens</span><span class="hl-1">, </span><span class="hl-0">chunkBitSize</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="md:bound-check-range-proof" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Bound check (range proof)<a href="#md:bound-check-range-proof" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Note: This section assumes you have read some of the previous examples on composite proof.</p>
<p>A complete example as a test is <a href="media/bound-check.spec.ts">here</a></p>
<p>Allows a verifier to check that some attribute of the credential satisfies given bounds <code>min</code> and <code>max</code>, i.e. <code>min &lt;= message &lt; max</code>
without learning the attribute itself. Both <code>min</code> and <code>max</code> are positive integers. This can be implemented using different protocols,</p>
<ul>
<li>LegoGroth16, a protocol described in the SNARK framework <a href="https://eprint.iacr.org/2019/142" target="_blank" class="external">Legosnark</a> in appendix H.2. Requires a trusted setup, which in practice is done by the verifier.</li>
<li>Bulletproofs++, a transparent (no trusted setup required) range proof protocol.</li>
<li>Set-membership check based range proof which require a trusted setup but offer 2 variations - one with keyed verification which has the most optimal execution
and the other that performs similar to LegoGroth16 for proving but worse in verification.</li>
</ul>
<p>The above mentioned test uses all these variations.</p>
<a id="md:encoding-for-negative-or-decimal-numbers" class="tsd-anchor"></a><h4 class="tsd-anchor-link">Encoding for negative or decimal numbers<a href="#md:encoding-for-negative-or-decimal-numbers" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h4><p>To work with negative integers or decimal numbers, they must be converted to positive integers first and this conversion must happen before these are signed.
When working with negative integers, add the absolute value of the smallest (negative) integer to all values including bounds. Eg, if the smallest negative
number a value can be is -300, the signer should sign <code>value + 300</code> to ensure that values are always positive. During the bound check, say the verifier has to
check if the value is between -200 and 50, the verifier should ask the prover to the bounds as 100 (-200 + 300) and 350 (50 + 300). When working with decimal
numbers, convert them to integers by multiplying with a number to make it integer, like if a decimal value can have maximum of 3 decimal places, they should be
multiplied by 1000.  The <a href="media/bound-check.spec.ts">test</a> mentioned above shows these scenarios.<br>
The conversions defined in the above tests are abstracted in this <a href="./src/bbs-plus/encoder.ts">Encoders</a> class and you can see the usage
in <a href="media/bound-check.spec-1.ts">these tests</a> of the  <code>Encoder</code> initialized <a href="media/data-and-encoder.ts">here</a>.</p>
<p>For this, the verifier needs to first create the setup parameters which he then shares with the prover. Note that the
verifier does not have to create them each time a proof needs to be verified, but only once and publish them somewhere
such that all provers interacting with the proof can use them.<br>
In the following snippet, the verifier asks to prove that a certain message satisfies the lower and upper bounds <code>min</code> and <code>max</code>,
i.e. <code>min &lt;= message &lt; max</code>. Note than both bounds are positive integers and lower bound is inclusive but upper bound is not.
To change from exclusive to inclusive bounds and vice-versa, add or subtract 1 from bounds. The snippet shows LegoGroth16.</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">BoundCheckSnarkSetup</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">provingKey</span><span class="hl-1"> = </span><span class="hl-5">BoundCheckSnarkSetup</span><span class="hl-1">();</span>
</code><button type="button">Copy</button></pre>

<p>For creating the proof of knowledge of the BBS signature and one of the signed message being in certain bounds, the prover creates the following 2 statements.</p>
<pre><code class="ts"><br/><span class="hl-4">// Signer&#39;s parameters</span><br/><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-0">sigParams</span><span class="hl-1">: </span><span class="hl-10">BBSSignature</span><span class="hl-1">, </span><span class="hl-0">pk</span><span class="hl-1">: </span><span class="hl-10">BBSPublicKey</span><span class="hl-1">, </span><span class="hl-0">sig</span><span class="hl-1">: </span><span class="hl-10">BBSSignature</span><span class="hl-1">;</span><br/><span class="hl-4">// Signed messages - already encoded</span><br/><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-0">messages</span><span class="hl-1">: </span><span class="hl-10">Uint8Array</span><span class="hl-1">[];</span><br/><span class="hl-1">...</span><br/><span class="hl-4">// define the min and max bounds</span><br/><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-0">min</span><span class="hl-1">: </span><span class="hl-10">number</span><span class="hl-1"> = ...;</span><br/><span class="hl-7">let</span><span class="hl-1"> </span><span class="hl-0">max</span><span class="hl-1">: </span><span class="hl-10">number</span><span class="hl-1"> = ...;</span><br/><span class="hl-1">...</span><br/><span class="hl-4">// Decompress the proving key </span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">snarkProvingKey</span><span class="hl-1"> = </span><span class="hl-0">provingKey</span><span class="hl-1">.</span><span class="hl-5">decompress</span><span class="hl-1">();</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement1</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureProverConstantTime</span><span class="hl-1">(</span><span class="hl-0">sigParams</span><span class="hl-1">, </span><span class="hl-0">revealedMsgs</span><span class="hl-1">, </span><span class="hl-7">false</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement2</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">boundCheckLegoProver</span><span class="hl-1">(</span><span class="hl-0">min</span><span class="hl-1">, </span><span class="hl-0">max</span><span class="hl-1">, </span><span class="hl-0">snarkProvingKey</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proverStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Statements</span><span class="hl-1">();</span><br/><span class="hl-0">proverStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement1</span><span class="hl-1">);</span><br/><span class="hl-0">proverStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement2</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p><code>statement1</code> is the for proving knowledge of a BBS signature as seen in previous examples. <code>statement2</code> is for proving the bounds of a message from the BBS signature.</p>
<p>Some things to note about this statement:</p>
<ul>
<li>The statement is created using <code>Statement.boundCheckLegoProver</code> because it is being created by a prover. A verifier would have
used <code>Statement.boundCheckLegoVerifier</code> to create it and one of the arguments would be different (shown below).</li>
<li>The argument <code>snarkProvingKey</code> is the public parameter created by the verifier. However, before they are passed to <code>Statement.boundCheckLegoProver</code>, they are uncompressed (ref. elliptic curve point compression) as shown in the above snippet. Uncompressing them doubles their size but makes them faster to work with. However, if you still want to use the compressed parameters use <code>Statement.boundCheckLegoProverFromCompressedParams</code></li>
</ul>
<p>The prover then establishes the equality between the message in the BBS signature and the bounded message by using
<code>WitnessEqualityMetaStatement</code> as below. <code>msgIdx</code> is the index of the bounded message in the array of signed messages
under BBS, <code>messages</code>. For the second statement, there is only 1 witness, thus the index 0.</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">WitnessEqualityMetaStatement</span><span class="hl-1">, </span><span class="hl-0">MetaStatement</span><span class="hl-1">, </span><span class="hl-0">MetaStatements</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnessEq</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">WitnessEqualityMetaStatement</span><span class="hl-1">();</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">msgIdx</span><span class="hl-1"> = </span><span class="hl-9">3</span><span class="hl-1">;  </span><span class="hl-4">// the index of the SSN number</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-0">msgIdx</span><span class="hl-1">);</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">metaStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">MetaStatements</span><span class="hl-1">();</span><br/><span class="hl-0">metaStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">MetaStatement</span><span class="hl-1">.</span><span class="hl-5">witnessEquality</span><span class="hl-1">(</span><span class="hl-0">witnessEq</span><span class="hl-1">));</span>
</code><button type="button">Copy</button></pre>

<p>The prover then creates witness for both statements. The message <code>messages[msgIdx]</code> passed to <code>Witness.boundCheckLegoGroth16</code> is the
bounded message. <code>unrevealedMsgs</code> passed to <code>Witness.bbsSignatureConstantTime</code> is created from <code>messages</code> and consists of
messages not being revealed to the verifier.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witness1</span><span class="hl-1"> = </span><span class="hl-0">Witness</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureConstantTime</span><span class="hl-1">(</span><span class="hl-0">sig</span><span class="hl-1">, </span><span class="hl-0">unrevealedMsgs</span><span class="hl-1">, </span><span class="hl-7">false</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witness2</span><span class="hl-1"> = </span><span class="hl-0">Witness</span><span class="hl-1">.</span><span class="hl-5">boundCheckLegoGroth16</span><span class="hl-1">(</span><span class="hl-0">messages</span><span class="hl-1">[</span><span class="hl-0">msgIdx</span><span class="hl-1">]);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnesses</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Witnesses</span><span class="hl-1">();</span><br/><span class="hl-0">witnesses</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">witness1</span><span class="hl-1">);</span><br/><span class="hl-0">witnesses</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">witness2</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>The prover then creates a proof specification using <code>QuasiProofSpec</code>. This is different from <code>ProofSpec</code> object seen in
previous examples as it does not call WASM to get a proof specification object and thus is more efficient.<br>
Now prover creates the proof using <code>CompositeProof.generateUsingQuasiProofSpec</code></p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">QuasiProofSpec</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proverProofSpec</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">QuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">proverStatements</span><span class="hl-1">, </span><span class="hl-0">metaStatements</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proof</span><span class="hl-1"> = </span><span class="hl-0">CompositeProof</span><span class="hl-1">.</span><span class="hl-5">generateUsingQuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">proverProofSpec</span><span class="hl-1">, </span><span class="hl-0">witnesses</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Similarly, the verifier also creates 2 statements and the same meta statement to verify the proof.</p>
<pre><code class="ts"><span class="hl-4">// Get the uncompressed verifying key from the compressed proving key.</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">snarkVerifyingKey</span><span class="hl-1"> = </span><span class="hl-0">provingKey</span><span class="hl-1">.</span><span class="hl-5">getVerifyingKeyUncompressed</span><span class="hl-1">();</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement1</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">bbsSignatureVerifierConstantTime</span><span class="hl-1">(</span><span class="hl-0">sigParams</span><span class="hl-1">, </span><span class="hl-0">sigPk</span><span class="hl-1">, </span><span class="hl-0">revealedMsgs</span><span class="hl-1">, </span><span class="hl-7">false</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement2</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">boundCheckLegoVerifier</span><span class="hl-1">(</span><span class="hl-0">min</span><span class="hl-1">, </span><span class="hl-0">max</span><span class="hl-1">, </span><span class="hl-0">snarkVerifyingKey</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">verifierStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Statements</span><span class="hl-1">();</span><br/><span class="hl-0">verifierStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement1</span><span class="hl-1">);</span><br/><span class="hl-0">verifierStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement2</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">witnessEq</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">WitnessEqualityMetaStatement</span><span class="hl-1">();</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-0">msgIdx</span><span class="hl-1">);</span><br/><span class="hl-0">witnessEq</span><span class="hl-1">.</span><span class="hl-5">addWitnessRef</span><span class="hl-1">(</span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-9">0</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">metaStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">MetaStatements</span><span class="hl-1">();</span><br/><span class="hl-0">metaStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">MetaStatement</span><span class="hl-1">.</span><span class="hl-5">witnessEquality</span><span class="hl-1">(</span><span class="hl-0">witnessEq</span><span class="hl-1">));</span>
</code><button type="button">Copy</button></pre>

<p>The above has a few differences from the prover's statements:</p>
<ul>
<li>Instead of using <code>Statement.boundCheckLegoProver</code>, verifier uses <code>Statement.boundCheckLegoVerifier</code>.</li>
<li>Instead of proving key, verifier uses verifying key for the snark.</li>
</ul>
<p>The verifier now creates the proof specification and verifies the proof.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">verifierProofSpec</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">QuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">verifierStatements</span><span class="hl-1">, </span><span class="hl-0">metaStatements</span><span class="hl-1">);</span><br/><span class="hl-4">// result.verified should be true for the proof to be valid.</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">result</span><span class="hl-1"> = </span><span class="hl-0">proof</span><span class="hl-1">.</span><span class="hl-5">verifyUsingQuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">verifierProofSpec</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<a id="md:optimization" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Optimization<a href="#md:optimization" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>You might notice some public parameters are huge and also the statements involving them take noticeable time to create. Eg,
<code>snarkProvingKey</code>, <code>snarkVerifyingKey</code>, <code>saverEk</code> are huge and thus creating <code>Statement.saverProver</code>, <code>Statement.saverVerifier</code>,
<code>Statement.boundCheckLegoProver</code> and <code>Statement.boundCheckLegoVerifier</code> take some time to create. This becomes a bigger problem
when several messages need to be encrypted for the same decryptor or bounds over several messages need to be proved.<br>
To solve this, the public parameters don't need to be passed directly to the <code>Statement</code>s. They can be wrapped in a <code>SetupParam</code>
and then a reference to them is passed as an argument in place of the parameter itself to the <code>Statement</code>. See the snippet
below for creating 2 statements for verifiable encryption for the same setup parameters:</p>
<pre><code class="ts"><span class="hl-2">import</span><span class="hl-1"> { </span><span class="hl-0">SetupParam</span><span class="hl-1"> } </span><span class="hl-2">from</span><span class="hl-1"> </span><span class="hl-3">&#39;@docknetwork/crypto-wasm-ts&#39;</span><span class="hl-1">;</span><br/><br/><span class="hl-4">// Prover creates an array of `SetupParam`s</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proverSetupParams</span><span class="hl-1"> = [];</span><br/><span class="hl-0">proverSetupParams</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-0">SetupParam</span><span class="hl-1">.</span><span class="hl-5">saverEncryptionGensUncompressed</span><span class="hl-1">(</span><span class="hl-0">saverEncGens</span><span class="hl-1">));</span><br/><span class="hl-0">proverSetupParams</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-0">SetupParam</span><span class="hl-1">.</span><span class="hl-5">saverCommitmentGensUncompressed</span><span class="hl-1">(</span><span class="hl-0">commKey</span><span class="hl-1">));</span><br/><span class="hl-0">proverSetupParams</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-0">SetupParam</span><span class="hl-1">.</span><span class="hl-5">saverEncryptionKeyUncompressed</span><span class="hl-1">(</span><span class="hl-0">saverEk</span><span class="hl-1">));</span><br/><span class="hl-0">proverSetupParams</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-0">SetupParam</span><span class="hl-1">.</span><span class="hl-5">saverProvingKeyUncompressed</span><span class="hl-1">(</span><span class="hl-0">snarkProvingKey</span><span class="hl-1">));</span><br/><br/><span class="hl-4">// Passing reference to parameters as array indices from `proverSetupParams`</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement3</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">saverProverFromSetupParamRefs</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-9">2</span><span class="hl-1">, </span><span class="hl-9">3</span><span class="hl-1">, </span><span class="hl-0">chunkBitSize</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement4</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">saverProverFromSetupParamRefs</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-9">2</span><span class="hl-1">, </span><span class="hl-9">3</span><span class="hl-1">, </span><span class="hl-0">chunkBitSize</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Note the use of <code>Statement.saverProverFromSetupParamRefs</code> rather than <code>Statement.saverProver</code>. The arguments:</p>
<ul>
<li>0 for the encryption generators which are at index 0 in <code>proverSetupParams</code></li>
<li>1 for the commitment generators which are at index 1 in <code>proverSetupParams</code></li>
<li>2 for the encryption key which is at index 2 in <code>proverSetupParams</code></li>
<li>3 for the proving key which is at index 3 in <code>proverSetupParams</code></li>
</ul>
<p>Now the prover creates the proof specification by passing <code>SetupParam</code>s array as well.</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proverStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Statements</span><span class="hl-1">();</span><br/><span class="hl-1">...</span><br/><span class="hl-0">proverStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement3</span><span class="hl-1">);</span><br/><span class="hl-0">proverStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement4</span><span class="hl-1">);</span><br/><span class="hl-1">...</span><br/><span class="hl-1">...</span><br/><span class="hl-1">...</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proverProofSpec</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">QuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">proverStatements</span><span class="hl-1">, </span><span class="hl-0">metaStatements</span><span class="hl-1">, </span><span class="hl-0">proverSetupParams</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">proof</span><span class="hl-1"> = </span><span class="hl-0">CompositeProof</span><span class="hl-1">.</span><span class="hl-5">generateUsingQuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">proverProofSpec</span><span class="hl-1">, </span><span class="hl-0">witnesses</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>Similarly, the verifier can create his own <code>SetupParam</code>s array for his proof specification and then proof</p>
<pre><code class="ts"><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">verifierSetupParams</span><span class="hl-1"> = [];</span><br/><span class="hl-0">verifierSetupParams</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-0">SetupParam</span><span class="hl-1">.</span><span class="hl-5">saverEncryptionGensUncompressed</span><span class="hl-1">(</span><span class="hl-0">saverEncGens</span><span class="hl-1">));</span><br/><span class="hl-0">verifierSetupParams</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-0">SetupParam</span><span class="hl-1">.</span><span class="hl-5">saverCommitmentGensUncompressed</span><span class="hl-1">(</span><span class="hl-0">commKey</span><span class="hl-1">));</span><br/><span class="hl-0">verifierSetupParams</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-0">SetupParam</span><span class="hl-1">.</span><span class="hl-5">saverEncryptionKeyUncompressed</span><span class="hl-1">(</span><span class="hl-0">saverEk</span><span class="hl-1">));</span><br/><span class="hl-0">verifierSetupParams</span><span class="hl-1">.</span><span class="hl-5">push</span><span class="hl-1">(</span><span class="hl-0">SetupParam</span><span class="hl-1">.</span><span class="hl-5">saverVerifyingKeyUncompressed</span><span class="hl-1">(</span><span class="hl-0">snarkVerifyingKey</span><span class="hl-1">));</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement5</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">saverVerifierFromSetupParamRefs</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-9">2</span><span class="hl-1">, </span><span class="hl-9">3</span><span class="hl-1">, </span><span class="hl-0">chunkBitSize</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">statement6</span><span class="hl-1"> = </span><span class="hl-0">Statement</span><span class="hl-1">.</span><span class="hl-5">saverVerifierFromSetupParamRefs</span><span class="hl-1">(</span><span class="hl-9">0</span><span class="hl-1">, </span><span class="hl-9">1</span><span class="hl-1">, </span><span class="hl-9">2</span><span class="hl-1">, </span><span class="hl-9">3</span><span class="hl-1">, </span><span class="hl-0">chunkBitSize</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">verifierStatements</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">Statements</span><span class="hl-1">();</span><br/><span class="hl-1">...</span><br/><span class="hl-1">...</span><br/><span class="hl-0">verifierStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement5</span><span class="hl-1">);</span><br/><span class="hl-0">verifierStatements</span><span class="hl-1">.</span><span class="hl-5">add</span><span class="hl-1">(</span><span class="hl-0">statement6</span><span class="hl-1">);</span><br/><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">verifierProofSpec</span><span class="hl-1"> = </span><span class="hl-7">new</span><span class="hl-1"> </span><span class="hl-5">QuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">verifierStatements</span><span class="hl-1">, </span><span class="hl-0">metaStatements</span><span class="hl-1">, </span><span class="hl-0">verifierSetupParams</span><span class="hl-1">);</span><br/><span class="hl-7">const</span><span class="hl-1"> </span><span class="hl-8">result</span><span class="hl-1"> = </span><span class="hl-0">proof</span><span class="hl-1">.</span><span class="hl-5">verifyUsingQuasiProofSpec</span><span class="hl-1">(</span><span class="hl-0">verifierProofSpec</span><span class="hl-1">);</span>
</code><button type="button">Copy</button></pre>

<p>For a complete example, see <a href="media/saver.spec.ts">these tests</a></p>
<p>Similarly, for bound checks, use <code>Statement.boundCheckLegoProverFromSetupParamRefs</code> and <code>Statement.boundCheckVerifierFromSetupParamRefs</code>.<br>
For complete example, see <a href="media/bound-check.spec.ts">these tests</a></p>
<a id="md:working-with-messages-as-js-objects" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Working with messages as JS objects<a href="#md:working-with-messages-as-js-objects" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The above interfaces have been found to be a bit difficult to work with when signing messages/credentials that are represented as JS objects like</p>
<pre><code class="json"><span class="hl-1">{</span><br/><span class="hl-1">  </span><span class="hl-6">&quot;fname&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;John&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-6">&quot;lname&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;Smith&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-6">&quot;sensitive&quot;</span><span class="hl-1">: {</span><br/><span class="hl-1">    </span><span class="hl-6">&quot;secret&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;my-secret-that-wont-tell-anyone&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-6">&quot;email&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;john.smith@example.com&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-6">&quot;SSN&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;123-456789-0&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-6">&quot;user-id&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;user:123-xyz-#&quot;</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-6">&quot;location&quot;</span><span class="hl-1">: {</span><br/><span class="hl-1">    </span><span class="hl-6">&quot;country&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;USA&quot;</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-6">&quot;city&quot;</span><span class="hl-1">: </span><span class="hl-3">&quot;New York&quot;</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-6">&quot;timeOfBirth&quot;</span><span class="hl-1">: </span><span class="hl-9">1662010849619</span><span class="hl-1">,</span><br/><span class="hl-1">  </span><span class="hl-6">&quot;physical&quot;</span><span class="hl-1">: {</span><br/><span class="hl-1">    </span><span class="hl-6">&quot;height&quot;</span><span class="hl-1">: </span><span class="hl-9">181.5</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-6">&quot;weight&quot;</span><span class="hl-1">: </span><span class="hl-9">210</span><span class="hl-1">,</span><br/><span class="hl-1">    </span><span class="hl-6">&quot;BMI&quot;</span><span class="hl-1">: </span><span class="hl-9">23.25</span><br/><span class="hl-1">  },</span><br/><span class="hl-1">  </span><span class="hl-6">&quot;score&quot;</span><span class="hl-1">: </span><span class="hl-9">-13.5</span><br/><span class="hl-1">}</span>
</code><button type="button">Copy</button></pre>

<p><a href="media/sign-verify-js-objs.ts">Here</a> are some utilities to make this task a bit easier. The idea is to flatten the JSON, sort the keys alphabetically
to have a list with deterministic order and then use the <a href="media/encoder.ts">encoder</a> to encode each value as a field element (a number between 0 and another large number).<br>
The encoder can be configured to use different encoding functions for different keys to convert values from different types
like string, positive or negative integers or decimal numbers to field elements.<br>
<a href="tests/composite-proofs/msg-js-obj">The tests here</a> contain plenty of examples.</p>
<a id="md:writing-predicates-in-circom" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Writing predicates in Circom<a href="#md:writing-predicates-in-circom" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>Simple predicates like a range proof or equality of messages in zero knowledge are already hardcoded in the library but we
cannot imagine all the possible predicates different use-cases can require. We expect developers to write these predicates
in a programming language that we can then use to create zero-knowledge proofs. We currently support <a href="https://docs.circom.io/" target="_blank" class="external">Circom</a>, version 2.
The predicates can be written as Circom programs and then compiled for curve BLS12-381. The generated R1CS and WASM can then be feed
to the composite proof system to generate a zero knowledge proof of the predicate.</p>
<p>The workflow is this:</p>
<ol>
<li>Express the predicates/arbitrary computation as a Circom program.</li>
<li>Compile the above program to get the constraints (R1CS file) and witness generator (WASM file, takes input wires and calculates all the intermediate wires).</li>
<li>Use the constraints from step 2 to generate SNARK proving and verification key of LegoGroth16.</li>
<li>Use the R1CS and WASM files from step 2 and proving key from step 3 to create a LegoGroth16 proof.</li>
<li>Use the verification key from step 3 to verify the LegoGroth16 proof.</li>
</ol>
<p>The steps 1-3 are done by the verifier and the result of these steps, i.e. the program (<code>.circom</code> file), R1CS (<code>.r1cs</code> file),
WASM (<code>.wasm</code> file), proving and verification key are shared with any potential prover (published or shared P2P). Step 4 is
done by the prover and step 5 again by the verifier. Since R1CS and WASM files are harder to inspect that Circom programs,
to guard against a verifier tricking the prover to prove unintended predicates (and thus reveal more information than required),
a prover can take the Circom program and generate the R1CS and WASM files himself (do step 2 as well).</p>
<p>See some of the following tests for Circom usage:</p>
<ol>
<li><a href="media/yearly-income.spec.ts">The yearly income, calculate from monthly payslips is less/greater than certain amount.</a>.</li>
<li><a href="media/assets-liabilities.spec.ts">The sum of assets is greater than the sum of liabilities where are assets and liabilities are calculated from several credentials.</a></li>
<li><a href="media/blood-group.spec.ts">The blood group is not AB-</a></li>
<li><a href="media/grade.spec.ts">The grade is either A+, A, B+, B or C but nothing else.</a></li>
<li><a href="media/vaccination.spec.ts">Either vaccinated less than 30 days ago OR last checked negative less than 2 days ago</a></li>
<li><a href="media/all_receipts_different.spec.ts">All receipts (used as credentials) have different receipt (credential) ids</a>. This test shows using multiple circuits in a single proof.</li>
<li><a href="media/mimc-hash.spec.ts">Certain attribute is the preimage of an MiMC hash</a></li>
</ol>
<p>The Circom programs and corresponding R1CS and WASM files for the tests are <a href="./tests/circom">here</a>.</p>
<a id="md:anonymous-credentials" class="tsd-anchor"></a><h3 class="tsd-anchor-link">Anonymous credentials<a href="#md:anonymous-credentials" aria-label="Permalink" class="tsd-anchor-icon"><svg viewBox="0 0 24 24"><use href="assets/icons.svg#icon-anchor"></use></svg></a></h3><p>The composite proof system is used to implement anonymous credentials. See <a href="src/anonymous-credentials/">here</a> for details.</p>
<p><a href="https://www.slideshare.net/SSIMeetup/anonymous-credentials-with-range-proofs-verifiable-encryption-zksnarks-circom-support-and-blinded-issuance-lovesh-harchandani" target="_blank" class="external">Slides</a> and <a href="https://www.youtube.com/watch?v=e_E_6Fx5dro" target="_blank" class="external">video</a> for a presentation given at SSI meetup. Most of the presentation goes over the code, mostly anonymous credentials from this library.</p>
</div></div><div class="col-sidebar"><div class="page-menu"><div class="tsd-navigation settings"><details class="tsd-accordion"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="assets/icons.svg#icon-chevronDown"></use></svg>Settings</h3></summary><div class="tsd-accordion-details"><div class="tsd-filter-visibility"><span class="settings-label">Member Visibility</span><ul id="tsd-filter-options"><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-protected" name="protected"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Protected</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-inherited" name="inherited" checked/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>Inherited</span></label></li><li class="tsd-filter-item"><label class="tsd-filter-input"><input type="checkbox" id="tsd-filter-external" name="external"/><svg width="32" height="32" viewBox="0 0 32 32" aria-hidden="true"><rect class="tsd-checkbox-background" width="30" height="30" x="1" y="1" rx="6" fill="none"></rect><path class="tsd-checkbox-checkmark" d="M8.35422 16.8214L13.2143 21.75L24.6458 10.25" stroke="none" stroke-width="3.5" stroke-linejoin="round" fill="none"></path></svg><span>External</span></label></li></ul></div><div class="tsd-theme-toggle"><label class="settings-label" for="tsd-theme">Theme</label><select id="tsd-theme"><option value="os">OS</option><option value="light">Light</option><option value="dark">Dark</option></select></div></div></details></div><details open class="tsd-accordion tsd-page-navigation"><summary class="tsd-accordion-summary"><h3><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><use href="assets/icons.svg#icon-chevronDown"></use></svg>On This Page</h3></summary><div class="tsd-accordion-details"><a href="#md:crypto-wasm-ts"><span>crypto-<wbr/>wasm-<wbr/>ts</span></a><ul><li><a href="#md:contents"><span>Contents</span></a></li><li><a href="#md:getting-started"><span>Getting started</span></a></li><li><ul><li><a href="#md:build"><span>Build</span></a></li><li><a href="#md:test"><span>Test</span></a></li></ul></li><li><a href="#md:overview"><span>Overview</span></a></li><li><ul><li><a href="#md:bbs-signatures"><span>BBS <wbr/>Signatures</span></a></li><li><a href="#md:accumulator"><span>Accumulator</span></a></li><li><a href="#md:composite-proof"><span>Composite proof</span></a></li></ul></li><li><a href="#md:usage"><span>Usage</span></a></li><li><ul><li><a href="#md:supported-signature-schemes"><span>Supported <wbr/>Signature <wbr/>Schemes</span></a></li><li><a href="#md:bbs-signatures-1"><span>BBS signatures</span></a></li><li><ul><li><a href="#md:setup"><span>Setup</span></a></li><li><a href="#md:bytearray-messages"><span>Byte<wbr/>Array messages</span></a></li><li><a href="#md:signing-and-verification"><span>Signing and verification</span></a></li><li><a href="#md:proof-of-knowledge-of-signature"><span>Proof of knowledge of signature</span></a></li></ul></li><li><a href="#md:accumulators"><span>Accumulators</span></a></li><li><ul><li><a href="#md:setup-1"><span>Setup</span></a></li><li><a href="#md:updating-the-accumulator"><span>Updating the accumulator</span></a></li><li><a href="#md:generating-witnesses"><span>Generating witnesses</span></a></li><li><a href="#md:updating-witnesses"><span>Updating witnesses</span></a></li><li><a href="#md:prefilled-accumulator"><span>Prefilled accumulator</span></a></li></ul></li><li><a href="#md:composite-proofs"><span>Composite proofs</span></a></li><li><ul><li><a href="#md:terminology"><span>Terminology</span></a></li><li><a href="#md:examples"><span>Examples</span></a></li><li><ul><li><a href="#md:selective-disclosure"><span>Selective disclosure</span></a></li><li><a href="#md:bbs-signatures-over-null-valued-messages"><span>BBS signatures over null-<wbr/>valued messages</span></a></li><li><a href="#md:multiple-bbs-signatures"><span>Multiple BBS signatures</span></a></li><li><a href="#md:bbs-signature-together-with-accumulator-membership"><span>BBS signature together with accumulator membership</span></a></li><li><a href="#md:getting-a-blind-signature-example-applies-to-bbs"><span>Getting a blind signature (<wbr/>Example applies to BBS+)</span></a></li><li><a href="#md:pseudonyms"><span>Pseudonyms</span></a></li><li><a href="#md:social-kyc"><span>Social KYC</span></a></li></ul></li></ul></li><li><a href="#md:verifiable-encryption-using-saver"><span>Verifiable encryption using SAVER</span></a></li><li><ul><li><a href="#md:encoding-for-verifiable-encryption"><span>Encoding for verifiable encryption</span></a></li></ul></li><li><a href="#md:bound-check-range-proof"><span>Bound check (range proof)</span></a></li><li><ul><li><a href="#md:encoding-for-negative-or-decimal-numbers"><span>Encoding for negative or decimal numbers</span></a></li></ul></li><li><a href="#md:optimization"><span>Optimization</span></a></li><li><a href="#md:working-with-messages-as-js-objects"><span>Working with messages as JS objects</span></a></li><li><a href="#md:writing-predicates-in-circom"><span>Writing predicates in <wbr/>Circom</span></a></li><li><a href="#md:anonymous-credentials"><span>Anonymous credentials</span></a></li></ul></li></ul></div></details></div><div class="site-menu"><nav class="tsd-navigation"><a href="modules.html" class="current"><svg class="tsd-kind-icon" viewBox="0 0 24 24"><use href="assets/icons.svg#icon-1"></use></svg><span>@docknetwork/crypto-wasm-ts</span></a><ul class="tsd-small-nested-navigation" id="tsd-nav-container" data-base="."><li>Loading...</li></ul></nav></div></div></div><footer><p class="tsd-generator">Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p></footer><div class="overlay"></div></body></html>
