import { generateRandomFieldElement } from 'crypto-wasm-new';
import {
  AccumulatorPublicKey,
  AccumulatorSecretKey, areUint8ArraysEqual,
  BoundCheckBppParams,
  BoundCheckBppParamsUncompressed,
  BoundCheckParamType,
  BoundCheckProtocol,
  BoundCheckSmcParams,
  BoundCheckSmcParamsUncompressed,
  BoundCheckSmcWithKVProverParamsUncompressed,
  BoundCheckSmcWithKVSetup,
  BoundCheckSmcWithKVVerifierParamsUncompressed,
  CredentialSchema,
  DefaultSchemaParsingOpts,
  dockSaverEncryptionGens,
  InequalityProtocol,
  initializeWasm,
  LegoProvingKeyUncompressed,
  LegoVerifyingKeyUncompressed,
  MEM_CHECK_KV_STR,
  MEM_CHECK_STR,
  META_SCHEMA_STR,
  PositiveAccumulator,
  Pseudonym,
  PseudonymBases,
  randomFieldElement,
  SaverChunkedCommitmentKey,
  SaverDecryptionKeyUncompressed,
  SaverDecryptor,
  SaverEncryptionKeyUncompressed,
  SaverProvingKeyUncompressed,
  SaverSecretKey,
  SaverVerifyingKeyUncompressed,
  SUBJECT_STR,
  TYPE_STR,
  VB_ACCUMULATOR_22,
  VBMembershipWitness,
  VerifiableEncryptionProtocol
} from '../../src';
import {
  Credential,
  CredentialBuilder,
  isKvac,
  isPS,
  PresentationBuilder,
  PublicKey,
  Scheme,
  SecretKey
} from '../scheme';
import {
  checkResult,
  getBoundCheckSnarkKeys,
  readByteArrayFromFile,
  stringToBytes
} from '../utils';
import {
  checkCiphertext,
  checkPresentationJson,
  checkSchemaFromJson,
  getDecodedBoundedPseudonym,
  getExampleBuilder,
  getExampleSchema,
  getKeys,
  setupPrefilledAccum,
  verifyCred
} from './utils';

// Setting it to false will make the test run the SNARK setups making tests quite slow
const loadSnarkSetupFromFiles = true;

describe.each([true, false])(
  `${Scheme} Presentation creation and verification with withSchemaRef=%s`,
  (withSchemaRef) => {
    let sk1: SecretKey, pk1: PublicKey;
    let sk2: SecretKey, pk2: PublicKey;
    let sk3: SecretKey, pk3: PublicKey;
    let sk4: SecretKey, pk4: PublicKey;

    let credential1: Credential;
    let credential2: Credential;
    let credential3: Credential;
    let credential4: Credential;
    let credential5: Credential;
    let credential6: Credential;
    let credential7: Credential;

    // generated by verifier:
    const scope1 = stringToBytes('Service provider 1');

    let accumulator3: PositiveAccumulator;
    let accumulator3Sk: AccumulatorSecretKey;
    let accumulator3Pk: AccumulatorPublicKey;
    let accumulator3Witness: VBMembershipWitness;

    let accumulator4: PositiveAccumulator;
    let accumulator4Sk: AccumulatorSecretKey;
    let accumulator4Pk: AccumulatorPublicKey;
    let accumulator4Witness: VBMembershipWitness;

    let boundCheckProvingKey: LegoProvingKeyUncompressed;
    let boundCheckVerifyingKey: LegoVerifyingKeyUncompressed;

    const chunkBitSize = 16;
    let saverSk: SaverProvingKeyUncompressed;
    let saverProvingKey: SaverProvingKeyUncompressed;
    let saverVerifyingKey: SaverVerifyingKeyUncompressed;
    let saverEk: SaverEncryptionKeyUncompressed;
    let saverDk: SaverDecryptionKeyUncompressed;

    let boundCheckBppParams: BoundCheckBppParamsUncompressed;
    let boundCheckSmcParams: BoundCheckSmcParamsUncompressed;
    let boundCheckSmcKVProverParams: BoundCheckSmcWithKVProverParamsUncompressed;
    let boundCheckSmcKVVerifierParams: BoundCheckSmcWithKVVerifierParamsUncompressed;

    const nonEmbeddedSchema = {
      $id: 'https://example.com?hash=abc123ff',
      [META_SCHEMA_STR]: 'http://json-schema.org/draft-07/schema#',
      type: 'object'
    };

    function setupBoundCheckLego() {
      if (boundCheckProvingKey === undefined) {
        [boundCheckProvingKey, boundCheckVerifyingKey] = getBoundCheckSnarkKeys(loadSnarkSetupFromFiles);
      }
    }

    function setupSaver() {
      if (saverProvingKey === undefined) {
        if (loadSnarkSetupFromFiles) {
          saverSk = new SaverSecretKey(readByteArrayFromFile('snark-setups/saver-secret-key-16.bin'));
          saverProvingKey = new SaverProvingKeyUncompressed(
            readByteArrayFromFile('snark-setups/saver-proving-key-16-uncompressed.bin')
          );
          saverVerifyingKey = new SaverVerifyingKeyUncompressed(
            readByteArrayFromFile('snark-setups/saver-verifying-key-16-uncompressed.bin')
          );
          saverEk = new SaverEncryptionKeyUncompressed(
            readByteArrayFromFile('snark-setups/saver-encryption-key-16-uncompressed.bin')
          );
          saverDk = new SaverDecryptionKeyUncompressed(
            readByteArrayFromFile('snark-setups/saver-decryption-key-16-uncompressed.bin')
          );
        } else {
          const encGens = dockSaverEncryptionGens();
          const [saverSnarkPk, saverSec, encryptionKey, decryptionKey] = SaverDecryptor.setup(encGens, chunkBitSize);
          saverSk = saverSec;
          saverProvingKey = saverSnarkPk.decompress();
          saverVerifyingKey = saverSnarkPk.getVerifyingKeyUncompressed();
          saverEk = encryptionKey.decompress();
          saverDk = decryptionKey.decompress();
        }
      }
    }

    function setupBoundCheckBpp() {
      if (boundCheckBppParams === undefined) {
        const p = new BoundCheckBppParams(stringToBytes('Bulletproofs++ testing'));
        boundCheckBppParams = p.decompress();
      }
    }

    function setupBoundCheckSmc() {
      if (boundCheckSmcParams === undefined) {
        const p = new BoundCheckSmcParams(stringToBytes('set-membership check based range proof testing'));
        boundCheckSmcParams = p.decompress();
      }
    }

    function setupBoundCheckSmcWithKV() {
      if (boundCheckSmcKVProverParams === undefined) {
        const p = BoundCheckSmcWithKVSetup(
          stringToBytes('set-membership check based range proof with keyed verification testing')
        );
        boundCheckSmcKVProverParams = p[0].decompress();
        boundCheckSmcKVVerifierParams = p[1].decompress();
      }
    }

    beforeAll(async () => {
      await initializeWasm();
      [sk1, pk1] = getKeys('seed1');
      [sk2, pk2] = getKeys('seed2');
      [sk3, pk3] = getKeys('seed3');
      [sk4, pk4] = getKeys('seed4');

      const schema1 = getExampleSchema(9);
      const builder1 = new CredentialBuilder();
      if (withSchemaRef) {
        builder1.schema = new CredentialSchema(nonEmbeddedSchema, DefaultSchemaParsingOpts, true, undefined, schema1);
      } else {
        builder1.schema = new CredentialSchema(schema1);
      }
      builder1.subject = {
        fname: 'John',
        lname: 'Smith',
        email: 'john.smith@example.com',
        SSN: '123-456789-0',
        userId: 'user:123-xyz-#',
        country: 'USA',
        city: 'New York',
        timeOfBirth: 1662010849619,
        height: 181.5,
        weight: 210.4,
        BMI: 23.25,
        score: -13.5,
        secret: 'my-secret-that-wont-tell-anyone'
      };
      credential1 = builder1.sign(sk1);
      verifyCred(credential1, pk1, sk1);

      const schema2 = getExampleSchema(11);
      const builder2 = new CredentialBuilder();
      if (withSchemaRef) {
        builder2.schema = new CredentialSchema(nonEmbeddedSchema, DefaultSchemaParsingOpts, true, undefined, schema2);
      } else {
        builder2.schema = new CredentialSchema(schema2);
      }
      builder2.subject = {
        fname: 'John',
        lname: 'Smith',
        isbool: true,
        sensitive: {
          secret: 'my-secret-that-wont-tell-anyone',
          email: 'john.smith@example.com',
          SSN: '123-456789-0',
          userId: 'user:123-xyz-#'
        },
        location: {
          country: 'USA',
          city: 'New York'
        },
        timeOfBirth: 1662010849619,
        physical: {
          height: 181.5,
          weight: 210,
          BMI: 23.25
        },
        score: -13.5
      };
      credential2 = builder2.sign(sk2);
      verifyCred(credential2, pk2, sk2);

      const schema3 = getExampleSchema(5);
      let credSchema3: CredentialSchema;
      if (withSchemaRef) {
        credSchema3 = new CredentialSchema(nonEmbeddedSchema, DefaultSchemaParsingOpts, true, undefined, schema3);
      } else {
        credSchema3 = new CredentialSchema(schema3);
      }
      const builder3 = new CredentialBuilder();
      builder3.schema = credSchema3;
      builder3.subject = {
        fname: 'John',
        lname: 'Smith',
        sensitive: {
          very: {
            secret: 'my-secret-that-wont-tell-anyone'
          },
          email: 'john.smith@acme.com',
          phone: '801009801',
          SSN: '123-456789-0'
        },
        lessSensitive: {
          location: {
            country: 'USA',
            city: 'New York'
          },
          department: {
            name: 'Random',
            location: {
              name: 'Somewhere',
              geo: {
                lat: -23.658,
                long: 2.556
              }
            }
          }
        },
        rank: 6
      };
      builder3.setCredentialStatus('dock:accumulator:accumId123', MEM_CHECK_STR, 'user:A-123');
      credential3 = builder3.sign(sk3);
      verifyCred(credential3, pk3, sk3);

      const seed = stringToBytes('secret-seed-for-accum');
      // @ts-ignore
      [accumulator3Sk, accumulator3Pk, accumulator3, accumulator3Witness] = await setupPrefilledAccum(200, 122, 'user:A-', credSchema3, seed);

      const schema4 = getExampleSchema(10);

      let credSchema4: CredentialSchema;
      if (withSchemaRef) {
        credSchema4 = new CredentialSchema(nonEmbeddedSchema, DefaultSchemaParsingOpts, true, undefined, schema4);
      } else {
        credSchema4 = new CredentialSchema(schema4);
      }
      const builder4 = new CredentialBuilder();
      builder4.schema = credSchema4;
      builder4.subject = {
        fname: 'John',
        lname: 'Smith',
        sensitive: {
          email: 'john.smith@example.edu',
          SSN: '123-456789-0'
        },
        education: {
          studentId: 's-22-123450',
          university: {
            name: 'Example University',
            registrationNumber: 'XYZ-123-789'
          },
          transcript: {
            rank: 100,
            CGPA: 2.57,
            scores: {
              english: 60,
              mathematics: 70,
              science: 50,
              history: 45,
              geography: 40
            }
          }
        }
      };
      builder4.setCredentialStatus('dock:accumulator:accumId124', MEM_CHECK_STR, 'tran:2022-YZ4-250');
      credential4 = builder4.sign(sk4);
      verifyCred(credential4, pk4, sk4);

      const seed1 = stringToBytes('secret-seed-for-accum-4');
      // @ts-ignore
      [accumulator4Sk, accumulator4Pk, accumulator4, accumulator4Witness] = await setupPrefilledAccum(300, 249, 'tran:2022-YZ4-', credSchema4, seed1);

      const schema5 = CredentialSchema.essential();
      const subjectItem = {
        type: 'object',
        properties: {
          name: { type: 'string' },
          location: {
            type: 'object',
            properties: {
              name: { type: 'string' },
              geo: {
                type: 'object',
                properties: {
                  lat: { type: 'number', minimum: -90, multipleOf: 0.001 },
                  long: { type: 'number', minimum: -180, multipleOf: 0.001 }
                }
              }
            }
          }
        }
      };

      schema5.properties[SUBJECT_STR] = {
        type: 'array',
        items: [subjectItem, subjectItem, subjectItem]
      };
      const builder5 = new CredentialBuilder();
      if (withSchemaRef) {
        builder5.schema = new CredentialSchema(nonEmbeddedSchema, DefaultSchemaParsingOpts, true, undefined, schema5);
      } else {
        builder5.schema = new CredentialSchema(schema5);
      }
      builder5.subject = [
        {
          name: 'Random',
          location: {
            name: 'Somewhere',
            geo: {
              lat: -23.658,
              long: 2.556
            }
          }
        },
        {
          name: 'Random-1',
          location: {
            name: 'Somewhere-1',
            geo: {
              lat: 35.01,
              long: -40.987
            }
          }
        },
        {
          name: 'Random-2',
          location: {
            name: 'Somewhere-2',
            geo: {
              lat: -67.0,
              long: -10.12
            }
          }
        }
      ];
      credential5 = builder5.sign(sk1);
      verifyCred(credential5, pk1, sk1);

      const schema6 = CredentialSchema.essential();
      const subjectItem2 = {
        type: 'object',
        properties: {
          name: { type: 'string' },
          location: {
            type: 'object',
            properties: {
              name: { type: 'string' },
              geo: {
                type: 'object',
                properties: {
                  lat: { type: 'number', minimum: -90, multipleOf: 0.001 },
                  long: { type: 'number', minimum: -180, multipleOf: 0.001 }
                }
              }
            }
          }
        }
      };
      schema6.properties[SUBJECT_STR] = {
        type: 'array',
        items: [subjectItem2, subjectItem2, subjectItem2]
      };
      schema6.properties['issuer'] = {
        type: 'object',
        properties: {
          name: { type: 'string' },
          desc: { type: 'string' },
          logo: { type: 'string' }
        }
      };
      schema6.properties['issuanceDate'] = { type: 'integer', minimum: 0 };
      schema6.properties['expirationDate'] = { type: 'integer', minimum: 0 };

      const builder6 = new CredentialBuilder();
      if (withSchemaRef) {
        builder6.schema = new CredentialSchema(nonEmbeddedSchema, DefaultSchemaParsingOpts, true, undefined, schema6);
      } else {
        builder6.schema = new CredentialSchema(schema6);
      }
      builder6.subject = [
        {
          name: 'Random',
          location: {
            name: 'Somewhere',
            geo: {
              lat: -23.658,
              long: 2.556
            }
          }
        },
        {
          name: 'Random-1',
          location: {
            name: 'Somewhere-1',
            geo: {
              lat: 35.01,
              long: -40.987
            }
          }
        },
        {
          name: 'Random-2',
          location: {
            name: 'Somewhere-2',
            geo: {
              lat: -67.0,
              long: -10.12
            }
          }
        }
      ];
      builder6.setTopLevelField('issuer', {
        name: 'An issuer',
        desc: 'Just an issuer',
        logo: 'https://images.example-issuer.com/logo.png'
      });
      builder6.setTopLevelField('issuanceDate', 1662010849700);
      builder6.setTopLevelField('expirationDate', 1662011950934);
      credential6 = builder6.sign(sk1);
      verifyCred(credential6, pk1, sk1);

      // Schema with date type
      const schema7 = CredentialSchema.essential();
      schema7.properties[SUBJECT_STR] = {
        type: 'object',
        properties: {
          name: { type: 'string' },
          myDateTime: { type: 'string', format: 'date-time' },
          myDate: { type: 'string', format: 'date' }
        }
      };
      schema7.properties['issuanceDate'] = { type: 'integer', minimum: 0 };
      schema7.properties['expirationDate'] = { type: 'integer', minimum: 0 };

      const builder7 = new CredentialBuilder();
      if (withSchemaRef) {
        builder7.schema = new CredentialSchema(nonEmbeddedSchema, DefaultSchemaParsingOpts, true, undefined, schema7);
      } else {
        builder7.schema = new CredentialSchema(schema7);
      }
      builder7.subject = {
        name: 'Random',
        myDateTime: '2023-09-14T14:26:40.488Z',
        myDate: '2023-09-14'
      };
      builder7.setTopLevelField('issuanceDate', 1694719600488);
      builder7.setTopLevelField('expirationDate', 1994719600488);
      credential7 = builder7.sign(sk1);
      verifyCred(credential7, pk1, sk1);
    });

    it('from a flat credential - `credential1`', () => {
      const builder1 = new PresentationBuilder();
      expect(builder1.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      builder1.markAttributesRevealed(0, new Set<string>(['credentialSubject.fname', 'credentialSubject.lname']));
      const pres1 = builder1.finalize();

      // These checks are made by the verifier, i.e. verifier checks that the presentation is created from one credential
      expect(pres1.spec.credentials.length).toEqual(1);
      expect(pres1.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'John',
          lname: 'Smith'
        }
      });
      expect(pres1.spec.credentials[0].status).not.toBeDefined();

      expect(pres1.context).not.toBeDefined();
      expect(pres1.nonce).not.toBeDefined();

      checkResult(pres1.verify([pk1]));

      const presJson = pres1.toJSON();

      // The schema of the credential in the presentation matches the JSON-schema
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[0].schema, credential1.schema);

      checkPresentationJson(pres1, [pk1]);

      // Changing revealed attributes should fail the presentation verification
      pres1.spec.credentials[0].revealedAttributes['credentialSubject'].fname = 'Alice';
      expect(pres1.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'Alice',
          lname: 'Smith'
        }
      })
      expect(pres1.verify([pk1]).verified).toEqual(false);
    });

    it('from credential1 and credential2 - presenting pseudonyms', () => {
      // Service provider 1 (verifier 1) creates bases
      const base1ForSecretKey = PseudonymBases.generateBaseForSecretKey(scope1);
      // Pseudonym used is bound to 3 credential attributes
      const bases1ForAttributes = PseudonymBases.generateBasesForAttributes(3, scope1);
      // generated by prover:
      let proverSecretKey1 = generateRandomFieldElement();
      const attributeNames1 = new Map();

      // making sure encoding/decoding works correctly
      const decodedBaseForSecretKey = PseudonymBases.decodeBaseForSecretKey(base1ForSecretKey);
      const encodedBaseForSecretKey = PseudonymBases.encodeBaseForSecretKey(decodedBaseForSecretKey);
      expect(base1ForSecretKey).toEqual(encodedBaseForSecretKey);

      const builder1 = new PresentationBuilder();
      expect(builder1.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      expect(builder1.addCredential(credential2, isPS() ? pk2 : undefined)).toEqual(1);
      attributeNames1.set(0, ['credentialSubject.SSN', 'credentialSubject.email']);
      attributeNames1.set(1, ['credentialSubject.sensitive.userId']);
      expect(
        builder1.addBoundedPseudonym(bases1ForAttributes, attributeNames1, base1ForSecretKey, proverSecretKey1)
      ).toEqual(0);
      expect(builder1.addUnboundedPseudonym(base1ForSecretKey, proverSecretKey1)).toEqual(0);
      const pres1 = builder1.finalize();

      // verify boundedPseudonym generated locally by prover

      const [decodedBoundedPseudonym, basesForAttributes, baseForSecretKey] = getDecodedBoundedPseudonym(
        [credential1, credential1, credential2],
        ['SSN', 'email', 'sensitive.userId'],
        bases1ForAttributes,
        base1ForSecretKey,
        proverSecretKey1
      );
      expect(Object.keys(pres1.spec.boundedPseudonyms as object).length).toEqual(1);
      expect((pres1.spec.boundedPseudonyms as object)[decodedBoundedPseudonym]).toEqual({
        commitKey: {
          basesForAttributes: basesForAttributes,
          baseForSecretKey: baseForSecretKey
        },
        attributes: Object.fromEntries(attributeNames1)
      });

      // verify unboundedPseudonym generated locally by prover
      const expectedUnboundedPseudonym = Pseudonym.new(base1ForSecretKey, proverSecretKey1);
      const decodedUnboundedPseudonym = PseudonymBases.decode(expectedUnboundedPseudonym.value);
      expect(Object.keys(pres1.spec.unboundedPseudonyms as object).length).toEqual(1);
      expect((pres1.spec.unboundedPseudonyms as object)[decodedUnboundedPseudonym]).toEqual({
        commitKey: {
          baseForSecretKey: baseForSecretKey
        }
      });

      // verify that proofs on verifier side pass
      checkResult(pres1.verify([pk1, pk2]));

      checkPresentationJson(pres1, [pk1, pk2]);
    });

    it('from a credential with relaxed schema', () => {
      // The schema does not match the credential exactly

      for (let i = 1; i <= 12; i++) {
        const builder = getExampleBuilder(i);
        check(builder, sk1, pk1);
      }

      function check(credBuilder: CredentialBuilder, sk: SecretKey, pk: PublicKey) {
        const credential = credBuilder.sign(sk, undefined, { requireSameFieldsAsSchema: false });
        verifyCred(credential, pk, sk);
        const builder7 = new PresentationBuilder();
        expect(builder7.addCredential(credential, isPS() ? pk : undefined)).toEqual(0);
        const pres7 = builder7.finalize();

        expect(pres7.spec.credentials.length).toEqual(1);

        checkResult(pres7.verify([pk]));
        checkPresentationJson(pres7, [pk]);

        if (isKvac()) {
          checkResult(pres7.verify([sk]));
          checkPresentationJson(pres7, [sk]);
        }
      }
    });

    it('from with context and nonce', () => {
      const ctx = 'Test context: Someeee   vverrryyyyyy  longgggg   contexxxxttttt .............';
      const nonce = randomFieldElement();

      const builder1 = new PresentationBuilder();
      expect(builder1.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      builder1.markAttributesRevealed(0, new Set<string>(['credentialSubject.fname', 'credentialSubject.lname']));

      builder1.context = ctx;
      let pres = builder1.finalize();
      expect(pres.context).toEqual(ctx);
      expect(pres.nonce).not.toBeDefined();
      checkResult(pres.verify([pk1]));

      checkPresentationJson(pres, [pk1]);

      // Change the context to be something else and the presentation should not verify
      // @ts-ignore
      pres.context = 'Some other context';
      expect(pres.verify([pk1]).verified).toBe(false);

      const builder2 = new PresentationBuilder();
      expect(builder2.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      builder2.markAttributesRevealed(0, new Set<string>(['credentialSubject.fname', 'credentialSubject.lname']));

      builder2.context = ctx;
      builder2.nonce = nonce;
      pres = builder2.finalize();

      // These checks are made by the verifier, i.e. verifier checks that the nonce and context in the presentation are what's
      // expected and the presentation is valid.
      expect(pres.context).toEqual(ctx);
      expect(areUint8ArraysEqual(pres.nonce as Uint8Array, nonce)).toEqual(true);
      checkResult(pres.verify([pk1]));

      checkPresentationJson(pres, [pk1]);

      // Change the nonce to be something else and the presentation should not verify
      // @ts-ignore
      pres.nonce = randomFieldElement();
      expect(pres.verify([pk1]).verified).toBe(false);

      const builder3 = new PresentationBuilder();
      expect(builder3.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      builder3.markAttributesRevealed(0, new Set<string>(['credentialSubject.fname', 'credentialSubject.lname']));

      builder3.nonce = nonce;
      pres = builder3.finalize();

      // These checks are made by the verifier, i.e. verifier checks that the nonce and context in the presentation are whats
      // expected and the presentation is valid.
      expect(pres.context).not.toBeDefined();
      expect(areUint8ArraysEqual(pres.nonce as Uint8Array, nonce)).toEqual(true);
      checkResult(pres.verify([pk1]));

      checkPresentationJson(pres, [pk1]);
    });

    it('from a nested credential - `credential2`', () => {
      const builder2 = new PresentationBuilder();
      expect(builder2.addCredential(credential2, isPS() ? pk2 : undefined)).toEqual(0);
      builder2.markAttributesRevealed(
        0,
        new Set<string>([
          'credentialSubject.fname',
          'credentialSubject.location.country',
          'credentialSubject.physical.BMI'
        ])
      );
      const pres2 = builder2.finalize();

      expect(pres2.spec.credentials.length).toEqual(1);
      expect(pres2.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'John',
          location: { country: 'USA' },
          physical: { BMI: 23.25 }
        }
      });
      expect(pres2.spec.credentials[0].status).not.toBeDefined();

      checkResult(pres2.verify([pk2]));

      const presJson = pres2.toJSON();

      // The schema of the credential in the presentation matches the JSON-schema
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[0].schema, credential2.schema);

      checkPresentationJson(pres2, [pk2]);
    });

    it('from a nested credential with credential status - `credential3`', () => {
      const builder3 = new PresentationBuilder();
      expect(builder3.addCredential(credential3, isPS() ? pk3 : undefined)).toEqual(0);
      builder3.markAttributesRevealed(
        0,
        new Set<string>([
          'credentialSubject.fname',
          'credentialSubject.lessSensitive.location.country',
          'credentialSubject.lessSensitive.department.location.name'
        ])
      );
      builder3.addAccumInfoForCredStatus(0, accumulator3Witness, accumulator3.accumulated, accumulator3Pk, {
        blockNo: 2010334
      });
      const pres3 = builder3.finalize();

      expect(pres3.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'John',
          lessSensitive: { location: { country: 'USA' }, department: { location: { name: 'Somewhere' } } }
        }
      });
      // This check is made by the verifier, i.e. verifier checks that the accumulator id, type, value and timestamp (`blockNo`)
      // are as expected
      expect(pres3.spec.getStatus(0)).toEqual({
        id: 'dock:accumulator:accumId123',
        [TYPE_STR]: VB_ACCUMULATOR_22,
        revocationCheck: MEM_CHECK_STR,
        accumulated: accumulator3.accumulated,
        extra: { blockNo: 2010334 }
      });

      // Verifier passes the accumulator public key for verification
      const acc = new Map();
      acc.set(0, accumulator3Pk);
      checkResult(pres3.verify([pk3], acc));

      const presJson = pres3.toJSON();

      // The schema of the credential in the presentation matches the JSON-schema
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[0].schema, credential3.schema);

      checkPresentationJson(pres3, [pk3], acc);
    });

    it('from 2 credentials, `credential1` and `credential2`, and prove some attributes equal', () => {
      const builder0 = new PresentationBuilder();
      expect(builder0.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      expect(builder0.addCredential(credential2, isPS() ? pk2 : undefined)).toEqual(1);
      builder0.enforceAttributeEquality([0, 'credentialSubject.SSN'], [1, 'credentialSubject.location.city']);
      builder0.enforceAttributeEquality([0, 'credentialSubject.city'], [1, 'credentialSubject.sensitive.SSN']);
      expect(() => builder0.finalize()).toThrow('Attribute equality not satisfied');

      const builder4 = new PresentationBuilder();
      expect(builder4.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      expect(builder4.addCredential(credential2, isPS() ? pk2 : undefined)).toEqual(1);

      builder4.markAttributesRevealed(0, new Set<string>(['credentialSubject.fname', 'credentialSubject.lname']));
      builder4.markAttributesRevealed(
        1,
        new Set<string>([
          'credentialSubject.fname',
          'credentialSubject.location.country',
          'credentialSubject.physical.BMI'
        ])
      );

      builder4.enforceAttributeEquality([0, 'credentialSubject.SSN'], [1, 'credentialSubject.sensitive.SSN']);
      builder4.enforceAttributeEquality([0, 'credentialSubject.city'], [1, 'credentialSubject.location.city']);
      builder4.enforceAttributeEquality([0, 'credentialSubject.height'], [1, 'credentialSubject.physical.height']);

      const pres4 = builder4.finalize();

      expect(pres4.spec.credentials.length).toEqual(2);
      expect(pres4.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'John',
          lname: 'Smith'
        }
      });
      expect(pres4.spec.credentials[1].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'John',
          location: { country: 'USA' },
          physical: { BMI: 23.25 }
        }
      });

      // Verifier checks that the desired attribute are proved equal
      expect(pres4.spec.attributeEqualities).toEqual([
        [[0, 'credentialSubject.SSN'], [1, 'credentialSubject.sensitive.SSN']],
        [[0, 'credentialSubject.city'], [1, 'credentialSubject.location.city']],
        [[0, 'credentialSubject.height'], [1, 'credentialSubject.physical.height']]
      ]);

      if (!isKvac()) {
        // Public keys in wrong order
        expect(pres4.verify([pk2, pk1]).verified).toEqual(false);

        // Public keys with wrong indices
        const pks = new Map();
        pks.set(0, pk2);
        pks.set(1, pk1);
        expect(pres4.verify(pks).verified).toEqual(false);
      }

      checkResult(pres4.verify([pk1, pk2]));

      const presJson = pres4.toJSON();

      // The schema of the credentials in the presentation matches their JSON-schema
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[0].schema, credential1.schema);
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[1].schema, credential2.schema);

      checkPresentationJson(pres4, [pk1, pk2]);
    });

    it('from 2 credentials, both having credential status', () => {
      const builder5 = new PresentationBuilder();
      expect(builder5.addCredential(credential3, isPS() ? pk3 : undefined)).toEqual(0);
      expect(builder5.addCredential(credential4, isPS() ? pk4 : undefined)).toEqual(1);

      builder5.markAttributesRevealed(
        0,
        new Set<string>([
          'credentialSubject.fname',
          'credentialSubject.lessSensitive.location.country',
          'credentialSubject.lessSensitive.department.location.name'
        ])
      );
      builder5.markAttributesRevealed(
        1,
        new Set<string>([
          'credentialSubject.education.university.name',
          'credentialSubject.education.university.registrationNumber'
        ])
      );

      builder5.enforceAttributeEquality([0, 'credentialSubject.sensitive.SSN'], [1, 'credentialSubject.sensitive.SSN']);
      builder5.enforceAttributeEquality([0, 'credentialSubject.lname'], [1, 'credentialSubject.lname']);

      builder5.addAccumInfoForCredStatus(0, accumulator3Witness, accumulator3.accumulated, accumulator3Pk, {
        blockNo: 2010334
      });
      builder5.addAccumInfoForCredStatus(1, accumulator4Witness, accumulator4.accumulated, accumulator4Pk, {
        blockNo: 2010340
      });

      const pres5 = builder5.finalize();

      expect(pres5.spec.credentials.length).toEqual(2);
      expect(pres5.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'John',
          lessSensitive: { location: { country: 'USA' }, department: { location: { name: 'Somewhere' } } }
        }
      });
      expect(pres5.spec.credentials[1].revealedAttributes).toEqual({
        credentialSubject: {
          education: { university: { name: 'Example University', registrationNumber: 'XYZ-123-789' } }
        }
      });

      // These checks are made by the verifier, i.e. verifier checks that the accumulator id, type, value and timestamp (`blockNo`)
      // are as expected for both credentials
      expect(pres5.spec.getStatus(0)).toEqual({
        id: 'dock:accumulator:accumId123',
        [TYPE_STR]: VB_ACCUMULATOR_22,
        revocationCheck: MEM_CHECK_STR,
        accumulated: accumulator3.accumulated,
        extra: { blockNo: 2010334 }
      });
      expect(pres5.spec.getStatus(1)).toEqual({
        id: 'dock:accumulator:accumId124',
        [TYPE_STR]: VB_ACCUMULATOR_22,
        revocationCheck: MEM_CHECK_STR,
        accumulated: accumulator4.accumulated,
        extra: { blockNo: 2010340 }
      });

      const acc = new Map();
      acc.set(0, accumulator3Pk);
      acc.set(1, accumulator4Pk);
      checkResult(pres5.verify([pk3, pk4], acc));

      const presJson = pres5.toJSON();

      // The schema of the credentials in the presentation matches their JSON-schema
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[0].schema, credential3.schema);
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[1].schema, credential4.schema);

      checkPresentationJson(pres5, [pk3, pk4], acc);
    });

    it('from multiple credentials, some having credential status (revocable) and some not', () => {
      const builder6 = new PresentationBuilder();
      expect(builder6.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      expect(builder6.addCredential(credential2, isPS() ? pk2 : undefined)).toEqual(1);
      expect(builder6.addCredential(credential3, isPS() ? pk3 : undefined)).toEqual(2);
      expect(builder6.addCredential(credential4, isPS() ? pk4 : undefined)).toEqual(3);

      builder6.markAttributesRevealed(0, new Set<string>(['credentialSubject.fname', 'credentialSubject.lname']));
      builder6.markAttributesRevealed(
        1,
        new Set<string>([
          'credentialSubject.fname',
          'credentialSubject.location.country',
          'credentialSubject.physical.BMI'
        ])
      );
      builder6.markAttributesRevealed(
        2,
        new Set<string>([
          'credentialSubject.fname',
          'credentialSubject.lessSensitive.location.country',
          'credentialSubject.lessSensitive.department.location.name'
        ])
      );
      builder6.markAttributesRevealed(
        3,
        new Set<string>([
          'credentialSubject.education.university.name',
          'credentialSubject.education.university.registrationNumber'
        ])
      );

      builder6.enforceAttributeEquality([0, 'credentialSubject.SSN'], [1, 'credentialSubject.sensitive.SSN']);
      builder6.enforceAttributeEquality([0, 'credentialSubject.city'], [1, 'credentialSubject.location.city']);
      builder6.enforceAttributeEquality([0, 'credentialSubject.height'], [1, 'credentialSubject.physical.height']);
      builder6.enforceAttributeEquality([2, 'credentialSubject.sensitive.SSN'], [3, 'credentialSubject.sensitive.SSN']);
      builder6.enforceAttributeEquality([2, 'credentialSubject.lname'], [3, 'credentialSubject.lname']);

      builder6.addAccumInfoForCredStatus(2, accumulator3Witness, accumulator3.accumulated, accumulator3Pk, {
        blockNo: 2010334
      });
      builder6.addAccumInfoForCredStatus(3, accumulator4Witness, accumulator4.accumulated, accumulator4Pk, {
        blockNo: 2010340
      });

      const pres6 = builder6.finalize();

      expect(pres6.spec.credentials.length).toEqual(4);
      expect(pres6.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'John',
          lname: 'Smith'
        }
      });
      expect(pres6.spec.credentials[1].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'John',
          location: { country: 'USA' },
          physical: { BMI: 23.25 }
        }
      });
      expect(pres6.spec.credentials[2].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'John',
          lessSensitive: { location: { country: 'USA' }, department: { location: { name: 'Somewhere' } } }
        }
      });
      expect(pres6.spec.credentials[3].revealedAttributes).toEqual({
        credentialSubject: {
          education: { university: { name: 'Example University', registrationNumber: 'XYZ-123-789' } }
        }
      });

      expect(pres6.spec.getStatus(2)).toEqual({
        id: 'dock:accumulator:accumId123',
        [TYPE_STR]: VB_ACCUMULATOR_22,
        revocationCheck: MEM_CHECK_STR,
        accumulated: accumulator3.accumulated,
        extra: { blockNo: 2010334 }
      });
      expect(pres6.spec.getStatus(3)).toEqual({
        id: 'dock:accumulator:accumId124',
        [TYPE_STR]: VB_ACCUMULATOR_22,
        revocationCheck: MEM_CHECK_STR,
        accumulated: accumulator4.accumulated,
        extra: { blockNo: 2010340 }
      });

      const acc = new Map();
      acc.set(2, accumulator3Pk);
      acc.set(3, accumulator4Pk);
      checkResult(pres6.verify([pk1, pk2, pk3, pk4], acc));
      checkResult(pres6.verify(new Map([[0, pk1], [1, pk2], [2, pk3], [3, pk4]]), acc));

      const presJson = pres6.toJSON();

      // The schema of the credentials in the presentation matches their JSON-schema
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[0].schema, credential1.schema);
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[1].schema, credential2.schema);
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[2].schema, credential3.schema);
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[3].schema, credential4.schema);

      checkPresentationJson(pres6, [pk1, pk2, pk3, pk4], acc);
      checkPresentationJson(pres6, new Map([[0, pk1], [1, pk2], [2, pk3], [3, pk4]]), acc);

      if (isKvac()) {
        checkResult(pres6.verify([sk1, sk2, sk3, sk4], acc));
        checkResult(pres6.verify(new Map([[0, sk1], [1, sk2], [2, sk3], [3, sk4]]), acc));
        checkPresentationJson(pres6, [sk1, sk2, sk3, sk4], acc);
        checkPresentationJson(pres6, new Map([[0, sk1], [1, sk2], [2, sk3], [3, sk4]]), acc);
      }
    });

    it('from credential `credential1` and proving some attributes inequal to public values', () => {
      // Check for error when the attribute is equal.
      const builder0 = new PresentationBuilder();
      expect(builder0.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      expect(credential1.subject.email).toEqual('john.smith@example.com');
      builder0.enforceAttributeInequality(0, 'credentialSubject.email', 'john.smith@example.com');
      expect(() => builder0.finalize()).toThrow('Attribute inequality for credentialSubject.email with john.smith@example.com not satisfied');

      const builder = new PresentationBuilder();
      expect(builder.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      expect(builder.addCredential(credential2, isPS() ? pk2 : undefined)).toEqual(1);
      expect(builder.addCredential(credential7, isPS() ? pk1 : undefined)).toEqual(2);

      builder.enforceAttributeEquality([0, 'credentialSubject.SSN'], [1, 'credentialSubject.sensitive.SSN']);

      const inEqualEmail = 'alice@example.com';
      const inEqualEmail2 = 'bob@example.com';
      const inequalTob = 1662010849600;
      const inequalTob2 = 1662010849601;
      const inequalTob3 = 1662010849602;
      const score = 3.5;
      const score2 = -10.1;
      const ssn = 'abcdf';
      const city = 'NYC';
      builder.enforceAttributeInequality(0, 'credentialSubject.email', inEqualEmail);
      builder.enforceAttributeInequality(0, 'credentialSubject.email', inEqualEmail2);
      builder.enforceAttributeInequality(0, 'credentialSubject.timeOfBirth', inequalTob);
      builder.enforceAttributeInequality(0, 'credentialSubject.timeOfBirth', inequalTob2);
      builder.enforceAttributeInequality(0, 'credentialSubject.timeOfBirth', inequalTob3);
      builder.enforceAttributeInequality(0, 'credentialSubject.score', score);
      builder.enforceAttributeInequality(0, 'credentialSubject.score', score2);
      builder.enforceAttributeInequality(0, 'credentialSubject.SSN', ssn);
      builder.enforceAttributeInequality(1, 'credentialSubject.sensitive.email', inEqualEmail);
      builder.enforceAttributeInequality(1, 'credentialSubject.sensitive.email', inEqualEmail2);
      builder.enforceAttributeInequality(1, 'credentialSubject.location.city', city);
      builder.enforceAttributeInequality(1, 'credentialSubject.isbool', false);
      builder.enforceAttributeInequality(2, 'credentialSubject.myDate', '2023-10-15');
      builder.enforceAttributeInequality(2, 'credentialSubject.myDate', new Date('2023-10-16'));

      const pres = builder.finalize();
      expect(pres.spec.credentials[0].attributeInequalities).toEqual({
        credentialSubject: {
          email: [
            { inEqualTo: inEqualEmail, protocol: InequalityProtocol.Uprove },
            { inEqualTo: inEqualEmail2, protocol: InequalityProtocol.Uprove }
          ],
          timeOfBirth: [
            { inEqualTo: inequalTob, protocol: InequalityProtocol.Uprove },
            { inEqualTo: inequalTob2, protocol: InequalityProtocol.Uprove },
            { inEqualTo: inequalTob3, protocol: InequalityProtocol.Uprove }
          ],
          score: [
            { inEqualTo: score, protocol: InequalityProtocol.Uprove },
            { inEqualTo: score2, protocol: InequalityProtocol.Uprove }
          ],
          SSN: [{ inEqualTo: ssn, protocol: InequalityProtocol.Uprove }]
        }
      });

      expect(pres.spec.credentials[1].attributeInequalities).toEqual({
        credentialSubject: {
          sensitive: {
            email: [
              { inEqualTo: inEqualEmail, protocol: InequalityProtocol.Uprove },
              { inEqualTo: inEqualEmail2, protocol: InequalityProtocol.Uprove }
            ]
          },
          location: {
            city: [{ inEqualTo: city, protocol: InequalityProtocol.Uprove }]
          },
          isbool: [{ inEqualTo: false, protocol: InequalityProtocol.Uprove }]
        }
      });

      expect(pres.spec.credentials[2].attributeInequalities).toEqual({
        credentialSubject: {
          myDate: [
            { inEqualTo: '2023-10-15', protocol: InequalityProtocol.Uprove },
            { inEqualTo: new Date('2023-10-16'), protocol: InequalityProtocol.Uprove }
          ],
        }
      });

      checkResult(pres.verify([pk1, pk2, pk1]));

      checkPresentationJson(pres, [pk1, pk2, pk1]);
    });

    function checkBounds(protocol: BoundCheckProtocol, paramId?: string, provingParams?: BoundCheckParamType, verifyingParams?: BoundCheckParamType) {
      // Check for error when the bounds are not satisfied.
      const builder0 = new PresentationBuilder();
      expect(builder0.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      const [minTime0, maxTime0] = [1662010850000, 1662010856123];
      // @ts-ignore
      expect(minTime0).not.toBeLessThan(credential1.subject['timeOfBirth']);
      // @ts-ignore
      expect(maxTime0).toBeGreaterThan(credential1.subject['timeOfBirth']);
      builder0.enforceBounds(0, 'credentialSubject.timeOfBirth', minTime0, maxTime0, paramId, provingParams);
      expect(() => builder0.finalize()).toThrow('Value of attribute credentialSubject.timeOfBirth is 1662010849619 and is lesser than the minimum 1662010850000');

      const builder00 = new PresentationBuilder();
      expect(builder00.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      const [minTime00, maxTime00] = [1662010838000, 1662010849600];
      // @ts-ignore
      expect(minTime00).toBeLessThan(credential1.subject['timeOfBirth']);
      // @ts-ignore
      expect(maxTime00).not.toBeGreaterThan(credential1.subject['timeOfBirth']);
      builder00.enforceBounds(0, 'credentialSubject.timeOfBirth', minTime00, maxTime00, paramId, provingParams);
      expect(() => builder00.finalize()).toThrow('Value of attribute credentialSubject.timeOfBirth is 1662010849619 and is greater than or equal to the maximum 1662010849600');

      // ------------------- Presentation with 1 credential -----------------------------------------
      console.time(`Proof generation over 1 credential and 3 bound-check in total using ${protocol}`);
      const builder7 = new PresentationBuilder();
      expect(builder7.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);

      builder7.markAttributesRevealed(0, new Set<string>(['credentialSubject.fname', 'credentialSubject.lname']));

      const [minTime, maxTime] = [1662010838000, 1662010856123];
      // @ts-ignore
      expect(minTime).toBeLessThan(credential1.subject['timeOfBirth']);
      // @ts-ignore
      expect(maxTime).toBeGreaterThan(credential1.subject['timeOfBirth']);
      builder7.enforceBounds(0, 'credentialSubject.timeOfBirth', minTime, maxTime, paramId, provingParams);

      const [minBMI, maxBMI] = [10, 40];
      // @ts-ignore
      expect(minBMI).toBeLessThan(credential1.subject['BMI']);
      // @ts-ignore
      expect(maxBMI).toBeGreaterThan(credential1.subject['BMI']);
      builder7.enforceBounds(0, 'credentialSubject.BMI', minBMI, maxBMI, paramId);

      const [minScore, maxScore] = [-40.5, 60.7];
      // @ts-ignore
      expect(minScore).toBeLessThan(credential1.subject['score']);
      // @ts-ignore
      expect(maxScore).toBeGreaterThan(credential1.subject['score']);
      builder7.enforceBounds(0, 'credentialSubject.score', minScore, maxScore, paramId);

      const pres1 = builder7.finalize();

      console.timeEnd(`Proof generation over 1 credential and 3 bound-check in total using ${protocol}`);

      expect(pres1.spec.credentials.length).toEqual(1);
      expect(pres1.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'John',
          lname: 'Smith'
        }
      });

      // These checks are made by the verifier, i.e. verifier checks that the bounds (min, max) for each attribute in the
      // presentation are what's expected and the presentation is valid.
      expect(pres1.spec.credentials[0].bounds).toEqual({
        credentialSubject: {
          timeOfBirth: [{
            min: minTime,
            max: maxTime,
            paramId: paramId,
            protocol: protocol
          }],
          BMI: [{
            min: minBMI,
            max: maxBMI,
            paramId: paramId,
            protocol: protocol
          }],
          score: [{
            min: minScore,
            max: maxScore,
            paramId: paramId,
            protocol: protocol
          }]
        }
      });

      console.time(`Proof verification over 1 credential and 3 bound-check in total using ${protocol}`);
      // Verifier passes the snark verification key for the presentation to verify
      const pp = new Map();
      pp.set(paramId, verifyingParams);
      checkResult(pres1.verify([pk1], undefined, pp));
      console.timeEnd(`Proof verification over 1 credential and 3 bound-check in total using ${protocol}`);

      checkPresentationJson(pres1, [pk1], undefined, pp);

      // ---------------------------------- Presentation with 3 credentials ---------------------------------

      console.time(`Proof generation over 3 credential and 5 bound-check in total using ${protocol}`);

      const builder8 = new PresentationBuilder();
      expect(builder8.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      expect(builder8.addCredential(credential2, isPS() ? pk2 : undefined)).toEqual(1);
      expect(builder8.addCredential(credential3, isPS() ? pk3 : undefined)).toEqual(2);

      builder8.markAttributesRevealed(0, new Set<string>(['credentialSubject.fname', 'credentialSubject.lname']));
      builder8.markAttributesRevealed(
        1,
        new Set<string>(['credentialSubject.fname', 'credentialSubject.location.country'])
      );
      builder8.markAttributesRevealed(
        2,
        new Set<string>([
          'credentialSubject.fname',
          'credentialSubject.lessSensitive.location.country',
          'credentialSubject.lessSensitive.department.location.name'
        ])
      );

      builder8.enforceAttributeEquality(
        [0, 'credentialSubject.SSN'],
        [1, 'credentialSubject.sensitive.SSN'],
        [2, 'credentialSubject.sensitive.SSN']
      );
      builder8.enforceAttributeEquality([0, 'credentialSubject.timeOfBirth'], [1, 'credentialSubject.timeOfBirth']);
      builder8.enforceAttributeEquality([0, 'credentialSubject.BMI'], [1, 'credentialSubject.physical.BMI']);
      builder8.enforceAttributeEquality([0, 'credentialSubject.score'], [1, 'credentialSubject.score']);

      builder8.addAccumInfoForCredStatus(2, accumulator3Witness, accumulator3.accumulated, accumulator3Pk, {
        blockNo: 2010334
      });

      builder8.enforceBounds(0, 'credentialSubject.timeOfBirth', minTime, maxTime, paramId, provingParams);
      builder8.enforceBounds(0, 'credentialSubject.BMI', minBMI, maxBMI, paramId);
      builder8.enforceBounds(0, 'credentialSubject.score', minScore, maxScore, paramId);

      const [minLat, maxLat] = [-30, 50];
      // @ts-ignore
      expect(minLat).toBeLessThan(credential3.subject.lessSensitive.department.location.geo.lat);
      // @ts-ignore
      expect(maxLat).toBeGreaterThan(credential3.subject.lessSensitive.department.location.geo.lat);
      builder8.enforceBounds(2, 'credentialSubject.lessSensitive.department.location.geo.lat', minLat, maxLat, paramId);

      const [minLong, maxLong] = [-10, 85];
      // @ts-ignore
      expect(minLong).toBeLessThan(credential3.subject.lessSensitive.department.location.geo.long);
      // @ts-ignore
      expect(maxLong).toBeGreaterThan(credential3.subject.lessSensitive.department.location.geo.long);
      builder8.enforceBounds(
        2,
        'credentialSubject.lessSensitive.department.location.geo.long',
        minLong,
        maxLong,
        paramId
      );

      const pres2 = builder8.finalize();

      console.timeEnd(`Proof generation over 3 credential and 5 bound-check in total using ${protocol}`);

      // These checks are made by the verifier, i.e. verifier checks that the bounds (min, max) for each attribute of the
      // corresponding credential in the presentation are what's expected and the presentation is valid.
      expect(pres2.spec.credentials[0].bounds).toEqual({
        credentialSubject: {
          timeOfBirth: [{
            min: minTime,
            max: maxTime,
            paramId: paramId,
            protocol: protocol
          }],
          BMI: [{
            min: minBMI,
            max: maxBMI,
            paramId: paramId,
            protocol: protocol
          }],
          score: [{
            min: minScore,
            max: maxScore,
            paramId: paramId,
            protocol: protocol
          }]
        }
      });

      expect(pres2.spec.credentials[2].bounds).toEqual({
        credentialSubject: {
          lessSensitive: {
            department: {
              location: {
                geo: {
                  lat: [{
                    min: minLat,
                    max: maxLat,
                    paramId: paramId,
                    protocol: protocol
                  }],
                  long: [{
                    min: minLong,
                    max: maxLong,
                    paramId: paramId,
                    protocol: protocol
                  }]
                }
              }
            }
          }
        }
      });
      expect(pres2.spec.getStatus(2)).toEqual({
        id: 'dock:accumulator:accumId123',
        [TYPE_STR]: VB_ACCUMULATOR_22,
        revocationCheck: 'membership',
        accumulated: accumulator3.accumulated,
        extra: { blockNo: 2010334 }
      });

      console.time(`Proof verification over 3 credential and 5 bound-check in total using ${protocol}`);
      const acc = new Map();
      acc.set(2, accumulator3Pk);

      const pp1 = new Map();
      pp1.set(paramId, verifyingParams);
      checkResult(pres2.verify([pk1, pk2, pk3], acc, pp1));
      console.timeEnd(`Proof verification over 3 credential and 5 bound-check in total using ${protocol}`);

      checkPresentationJson(pres2, [pk1, pk2, pk3], acc, pp1);
    }

    function checkBoundsOnDates(protocol: BoundCheckProtocol, paramId?: string, provingParams?: BoundCheckParamType, verifyingParams?: BoundCheckParamType) {
      // Check for error when the bounds are not satisfied.
      const builder0 = new PresentationBuilder();
      expect(builder0.addCredential(credential7, isPS() ? pk1 : undefined)).toEqual(0);
      const [minDateTime0, maxDateTime0] = [new Date('2023-10-14T14:26:40.488Z'), new Date('2024-09-14T14:26:40.488Z')];
      expect(minDateTime0.getTime()).not.toBeLessThan(new Date(credential7.subject['myDateTime']).getTime());
      expect(maxDateTime0.getTime()).toBeGreaterThan(new Date(credential7.subject['myDateTime']).getTime());
      builder0.enforceBounds(0, 'credentialSubject.myDateTime', minDateTime0, maxDateTime0, paramId, provingParams);
      expect(() => builder0.finalize()).toThrow('is lesser than the minimum');

      const builder00 = new PresentationBuilder();
      expect(builder00.addCredential(credential7, isPS() ? pk1 : undefined)).toEqual(0);
      const [minDateTime00, maxDateTime00] = [new Date('2022-09-14T14:26:40.488Z'), new Date('2023-05-14T14:26:40.488Z')];
      expect(minDateTime00.getTime()).toBeLessThan(new Date(credential7.subject['myDateTime']).getTime());
      expect(maxDateTime00.getTime()).not.toBeGreaterThan(new Date(credential7.subject['myDateTime']).getTime());
      builder00.enforceBounds(0, 'credentialSubject.myDateTime', minDateTime00, maxDateTime00, paramId, provingParams);
      expect(() => builder00.finalize()).toThrow('is greater than or equal to the maximum');

      console.time(`Proof generation over 1 credential and 2 bound-check in total using ${protocol}`);
      const builder7 = new PresentationBuilder();
      expect(builder7.addCredential(credential7, isPS() ? pk1 : undefined)).toEqual(0);

      builder7.markAttributesRevealed(0, new Set<string>(['credentialSubject.name']));

      const [minDateTime, maxDateTime] = [new Date('2022-09-14T14:26:40.488Z'), new Date('2024-09-14T14:26:40.488Z')];
      expect(minDateTime.getTime()).toBeLessThan(new Date(credential7.subject['myDateTime']).getTime());
      expect(maxDateTime.getTime()).toBeGreaterThan(new Date(credential7.subject['myDateTime']).getTime());
      builder7.enforceBounds(0, 'credentialSubject.myDateTime', minDateTime, maxDateTime, paramId, provingParams);

      // This call to enforceBounds will use strings, verifying the API works with Date obj or string value
      // we also use a negative timestamp here for testing
      const [minDate, maxDate] = [new Date('1800-09-14'), new Date('2024-09-14')];
      expect(minDate.getTime()).toBeLessThan(new Date(credential7.subject['myDate']).getTime());
      expect(maxDate.getTime()).toBeGreaterThan(new Date(credential7.subject['myDate']).getTime());
      builder7.enforceBounds(0, 'credentialSubject.myDate', minDate.toISOString(), maxDate.toISOString(), paramId);

      const pres1 = builder7.finalize();
      console.timeEnd(`Proof generation over 1 credential and 2 bound-check in total using ${protocol}`);

      // Enforce that the date bounds were not revealed
      expect(pres1.spec.credentials.length).toEqual(1);
      expect(pres1.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: {
          name: 'Random'
        }
      });

      // These checks are made by the verifier, i.e. verifier checks that the bounds (min, max) for each attribute in the
      // presentation are what's expected and the presentation is valid.
      expect(pres1.spec.credentials[0].bounds).toEqual({
        credentialSubject: {
          myDateTime: [{
            min: minDateTime.getTime(),
            max: maxDateTime.getTime(),
            paramId: paramId,
            protocol: protocol
          }],
          myDate: [{
            min: minDate.getTime(),
            max: maxDate.getTime(),
            paramId: paramId,
            protocol: protocol
          }]
        }
      });

      console.time(`Proof verification over 1 credential and 2 bound-check in total using ${protocol}`);
      // Verifier passes the snark verification key for the presentation to verify
      const pp = new Map();
      pp.set(paramId, verifyingParams);
      checkResult(pres1.verify([pk1], undefined, pp));
      console.timeEnd(`Proof verification over 1 credential and 2 bound-check in total using ${protocol}`);

      checkPresentationJson(pres1, [pk1], undefined, pp);
    }

    it('from credentials and proving bounds using LegoGroth16 on attributes as dates', () => {
      setupBoundCheckLego();
      checkBoundsOnDates(BoundCheckProtocol.Legogroth16, 'random', boundCheckProvingKey, boundCheckVerifyingKey);
    });

    it('from credentials and proving bounds using Bulletproofs++ on attributes as dates', () => {
      setupBoundCheckBpp();
      checkBoundsOnDates(BoundCheckProtocol.Bpp, 'random', boundCheckBppParams, boundCheckBppParams);
    });

    it('from credentials and proving bounds using Bulletproofs++ on attributes as dates and using default setup', () => {
      checkBoundsOnDates(BoundCheckProtocol.Bpp);
    });

    it('from credentials and proving bounds using set-membership check on attributes as dates', () => {
      setupBoundCheckSmc();
      checkBoundsOnDates(BoundCheckProtocol.Smc, 'random', boundCheckSmcParams, boundCheckSmcParams);
    });

    it('from credentials and proving bounds using set-membership check with keyed verification on attributes as dates', () => {
      setupBoundCheckSmcWithKV();
      checkBoundsOnDates(
        BoundCheckProtocol.SmcKV,
        'random',
        boundCheckSmcKVProverParams,
        boundCheckSmcKVVerifierParams,
      );
    });

    it('from credentials and proving bounds on attributes using LegorGroth16', () => {
      setupBoundCheckLego();
      checkBounds(BoundCheckProtocol.Legogroth16, 'random', boundCheckProvingKey, boundCheckVerifyingKey);
    });

    it('from credentials and proving bounds on attributes using Bulletproofs++', () => {
      setupBoundCheckBpp();
      checkBounds(BoundCheckProtocol.Bpp, 'random', boundCheckBppParams, boundCheckBppParams);
    });

    it('from credentials and proving bounds on attributes using Bulletproofs++ and using default setup', () => {
      checkBounds(BoundCheckProtocol.Bpp);
    });

    it('from credentials and proving bounds on attributes using set-membership check', () => {
      setupBoundCheckSmc();
      checkBounds(BoundCheckProtocol.Smc, 'random', boundCheckSmcParams, boundCheckSmcParams);
    });

    it('from credentials and proving bounds on attributes using set-membership check and keyed-verification', () => {
      setupBoundCheckSmcWithKV();
      checkBounds(BoundCheckProtocol.SmcKV, 'random', boundCheckSmcKVProverParams, boundCheckSmcKVVerifierParams);
    });

    it('from credentials and encryption of attributes', () => {
      // Setup for decryptor
      setupSaver();

      // ------------------- Presentation with 1 credential -----------------------------------------

      const ck = SaverChunkedCommitmentKey.generate(stringToBytes('some nonce'));
      const commKey = ck.decompress();

      const commKeyId = 'random-1';
      const ekId = 'random-2';
      const snarkPkId = 'random-3';

      const builder9 = new PresentationBuilder();
      expect(builder9.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);

      builder9.markAttributesRevealed(0, new Set<string>(['credentialSubject.fname', 'credentialSubject.lname']));
      builder9.verifiablyEncrypt(
        0,
        'credentialSubject.SSN',
        chunkBitSize,
        commKeyId,
        ekId,
        snarkPkId,
        commKey,
        saverEk,
        saverProvingKey
      );

      const pres1 = builder9.finalize();

      // Verifier checks that the correct encryption key and other parameters were used by the prover
      expect(pres1.spec.credentials[0].verifiableEncryptions).toEqual({
        credentialSubject: {
          SSN: [{
            chunkBitSize,
            commitmentGensId: commKeyId,
            encryptionKeyId: ekId,
            snarkKeyId: snarkPkId,
            protocol: VerifiableEncryptionProtocol.Saver
          }]
        }
      });

      // These checks are made by the verifier, i.e. verifier checks that the ciphertext for each required attribute is
      // present in the presentation and the presentation is valid. The verifier will preserve the ciphertext to be later
      // passed on to the decryptor
      // @ts-ignore
      expect(pres1.attributeCiphertexts.size).toEqual(1);
      // @ts-ignore
      expect(pres1.attributeCiphertexts.get(0)).toBeDefined();

      const pp = new Map();
      pp.set(commKeyId, commKey);
      pp.set(ekId, saverEk);
      pp.set(snarkPkId, saverVerifyingKey);
      checkResult(pres1.verify([pk1], undefined, pp));

      checkPresentationJson(pres1, [pk1], undefined, pp);

      expect(checkCiphertext(
        credential1,
        // @ts-ignore
        pres1.attributeCiphertexts?.get(0),
        'SSN',
        saverSk,
        saverDk,
        saverVerifyingKey,
        chunkBitSize
      )).toEqual(1);
      // ---------------------------------- Presentation with 3 credentials ---------------------------------

      const ckNew = SaverChunkedCommitmentKey.generate(stringToBytes('another nonce'));
      const commKeyNew = ckNew.decompress();

      const builder10 = new PresentationBuilder();
      expect(builder10.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      expect(builder10.addCredential(credential2, isPS() ? pk2 : undefined)).toEqual(1);
      expect(builder10.addCredential(credential3, isPS() ? pk3 : undefined)).toEqual(2);

      builder10.markAttributesRevealed(0, new Set<string>(['credentialSubject.fname', 'credentialSubject.lname']));
      builder10.markAttributesRevealed(
        1,
        new Set<string>(['credentialSubject.fname', 'credentialSubject.location.country'])
      );
      builder10.markAttributesRevealed(
        2,
        new Set<string>([
          'credentialSubject.fname',
          'credentialSubject.lessSensitive.location.country',
          'credentialSubject.lessSensitive.department.location.name'
        ])
      );

      builder10.enforceAttributeEquality(
        [0, 'credentialSubject.SSN'],
        [1, 'credentialSubject.sensitive.SSN'],
        [2, 'credentialSubject.sensitive.SSN']
      );
      builder10.enforceAttributeEquality([0, 'credentialSubject.userId'], [1, 'credentialSubject.sensitive.userId']);

      builder10.addAccumInfoForCredStatus(2, accumulator3Witness, accumulator3.accumulated, accumulator3Pk, {
        blockNo: 2010334
      });

      builder10.verifiablyEncrypt(
        0,
        'credentialSubject.SSN',
        chunkBitSize,
        commKeyId,
        ekId,
        snarkPkId,
        commKeyNew,
        saverEk,
        saverProvingKey
      );
      builder10.verifiablyEncrypt(1, 'credentialSubject.sensitive.userId', chunkBitSize, commKeyId, ekId, snarkPkId);

      const pres2 = builder10.finalize();

      expect(pres2.spec.credentials[0].verifiableEncryptions).toEqual({
        credentialSubject: {
          SSN: [{
            chunkBitSize,
            commitmentGensId: commKeyId,
            encryptionKeyId: ekId,
            snarkKeyId: snarkPkId,
            protocol: VerifiableEncryptionProtocol.Saver
          }]
        }
      });
      expect(pres2.spec.credentials[1].verifiableEncryptions).toEqual({
        credentialSubject: {
          sensitive: {
            userId: [{
              chunkBitSize,
              commitmentGensId: commKeyId,
              encryptionKeyId: ekId,
              snarkKeyId: snarkPkId,
              protocol: VerifiableEncryptionProtocol.Saver
            }]
          }
        }
      });
      expect(pres2.spec.getStatus(2)).toEqual({
        id: 'dock:accumulator:accumId123',
        [TYPE_STR]: VB_ACCUMULATOR_22,
        revocationCheck: 'membership',
        accumulated: accumulator3.accumulated,
        extra: { blockNo: 2010334 }
      });

      const acc = new Map();
      acc.set(2, accumulator3Pk);

      const pp1 = new Map();
      pp1.set(commKeyId, commKeyNew);
      pp1.set(ekId, saverEk);
      pp1.set(snarkPkId, saverVerifyingKey);

      checkResult(pres2.verify([pk1, pk2, pk3], acc, pp1));

      checkPresentationJson(pres2, [pk1, pk2, pk3], acc, pp1);

      // These checks are made by the verifier, i.e. verifier checks that the ciphertext for each required attribute in the
      // corresponding credential is present
      // @ts-ignore
      expect(pres2.attributeCiphertexts.size).toEqual(2);
      // @ts-ignore
      expect(pres2.attributeCiphertexts.get(0)).toBeDefined();
      // @ts-ignore
      expect(pres2.attributeCiphertexts.get(1)).toBeDefined();

      expect(checkCiphertext(
        credential1,
        // @ts-ignore
        pres2.attributeCiphertexts?.get(0),
        'SSN',
        saverSk,
        saverDk,
        saverVerifyingKey,
        chunkBitSize
      )).toEqual(1);

      expect(checkCiphertext(
        credential2,
        // @ts-ignore
        pres2.attributeCiphertexts?.get(1),
        'sensitive.userId',
        saverSk,
        saverDk,
        saverVerifyingKey,
        chunkBitSize
      )).toEqual(1);
    });

    it('from credentials with proving bounds on attributes and encryption of some attributes', () => {
      setupBoundCheckLego();
      setupSaver();

      const boundCheckSnarkId = 'random';
      const commKeyId = 'random-1';
      const ekId = 'random-2';
      const snarkPkId = 'random-3';

      const ck = SaverChunkedCommitmentKey.generate(stringToBytes('a new nonce'));
      const commKey = ck.decompress();

      const builder11 = new PresentationBuilder();
      expect(builder11.addCredential(credential1, isPS() ? pk1 : undefined)).toEqual(0);
      expect(builder11.addCredential(credential2, isPS() ? pk2 : undefined)).toEqual(1);
      expect(builder11.addCredential(credential3, isPS() ? pk3 : undefined)).toEqual(2);

      builder11.markAttributesRevealed(0, new Set<string>(['credentialSubject.fname', 'credentialSubject.lname']));
      builder11.markAttributesRevealed(
        1,
        new Set<string>(['credentialSubject.fname', 'credentialSubject.location.country'])
      );
      builder11.markAttributesRevealed(
        2,
        new Set<string>([
          'credentialSubject.fname',
          'credentialSubject.lessSensitive.location.country',
          'credentialSubject.lessSensitive.department.location.name'
        ])
      );

      builder11.enforceAttributeEquality(
        [0, 'credentialSubject.SSN'],
        [1, 'credentialSubject.sensitive.SSN'],
        [2, 'credentialSubject.sensitive.SSN']
      );
      builder11.enforceAttributeEquality([0, 'credentialSubject.timeOfBirth'], [1, 'credentialSubject.timeOfBirth']);
      builder11.enforceAttributeEquality([0, 'credentialSubject.BMI'], [1, 'credentialSubject.physical.BMI']);
      builder11.enforceAttributeEquality([0, 'credentialSubject.score'], [1, 'credentialSubject.score']);
      builder11.enforceAttributeEquality([0, 'credentialSubject.userId'], [1, 'credentialSubject.sensitive.userId']);

      builder11.addAccumInfoForCredStatus(2, accumulator3Witness, accumulator3.accumulated, accumulator3Pk, {
        blockNo: 2010334
      });

      const [minTime, maxTime] = [1662010838000, 1662010856123];
      // @ts-ignore
      expect(minTime).toBeLessThan(credential1.subject['timeOfBirth']);
      // @ts-ignore
      expect(maxTime).toBeGreaterThan(credential1.subject['timeOfBirth']);
      builder11.enforceBounds(
        0,
        'credentialSubject.timeOfBirth',
        minTime,
        maxTime,
        boundCheckSnarkId,
        boundCheckProvingKey
      );

      const [minBMI, maxBMI] = [10, 40];
      // @ts-ignore
      expect(minBMI).toBeLessThan(credential1.subject['BMI']);
      // @ts-ignore
      expect(maxBMI).toBeGreaterThan(credential1.subject['BMI']);
      builder11.enforceBounds(0, 'credentialSubject.BMI', minBMI, maxBMI, boundCheckSnarkId);

      const [minScore, maxScore] = [-40.5, 60.7];
      // @ts-ignore
      expect(minScore).toBeLessThan(credential1.subject['score']);
      // @ts-ignore
      expect(maxScore).toBeGreaterThan(credential1.subject['score']);
      builder11.enforceBounds(0, 'credentialSubject.score', minScore, maxScore, boundCheckSnarkId);

      const [minLat, maxLat] = [-30, 50];
      // @ts-ignore
      expect(minLat).toBeLessThan(credential3.subject.lessSensitive.department.location.geo.lat);
      // @ts-ignore
      expect(maxLat).toBeGreaterThan(credential3.subject.lessSensitive.department.location.geo.lat);
      builder11.enforceBounds(
        2,
        'credentialSubject.lessSensitive.department.location.geo.lat',
        minLat,
        maxLat,
        boundCheckSnarkId
      );

      const [minLong, maxLong] = [-10, 85];
      // @ts-ignore
      expect(minLong).toBeLessThan(credential3.subject.lessSensitive.department.location.geo.long);
      // @ts-ignore
      expect(maxLong).toBeGreaterThan(credential3.subject.lessSensitive.department.location.geo.long);
      builder11.enforceBounds(
        2,
        'credentialSubject.lessSensitive.department.location.geo.long',
        minLong,
        maxLong,
        boundCheckSnarkId
      );

      builder11.verifiablyEncrypt(
        0,
        'credentialSubject.SSN',
        chunkBitSize,
        commKeyId,
        ekId,
        snarkPkId,
        commKey,
        saverEk,
        saverProvingKey
      );
      builder11.verifiablyEncrypt(1, 'credentialSubject.sensitive.userId', chunkBitSize, commKeyId, ekId, snarkPkId);

      const pres1 = builder11.finalize();

      // Verifier checks that for the first credential, the bounds are satisfied and the attribute ciphertext is present
      expect(pres1.spec.credentials[0].bounds).toEqual({
        credentialSubject: {
          timeOfBirth: [{
            min: minTime,
            max: maxTime,
            paramId: boundCheckSnarkId,
            protocol: BoundCheckProtocol.Legogroth16
          }],
          BMI: [{
            min: minBMI,
            max: maxBMI,
            paramId: boundCheckSnarkId,
            protocol: BoundCheckProtocol.Legogroth16
          }],
          score: [{
            min: minScore,
            max: maxScore,
            paramId: boundCheckSnarkId,
            protocol: BoundCheckProtocol.Legogroth16
          }]
        }
      });
      expect(pres1.spec.credentials[0].verifiableEncryptions).toEqual({
        credentialSubject: {
          SSN: [{
            chunkBitSize,
            commitmentGensId: commKeyId,
            encryptionKeyId: ekId,
            snarkKeyId: snarkPkId,
            protocol: VerifiableEncryptionProtocol.Saver
          }]
        }
      });

      // Verifier checks that for the second credential, the bounds are satisfied and the attribute ciphertext is present
      expect(pres1.spec.credentials[2].bounds).toEqual({
        credentialSubject: {
          lessSensitive: {
            department: {
              location: {
                geo: {
                  lat: [{
                    min: minLat,
                    max: maxLat,
                    paramId: boundCheckSnarkId,
                    protocol: BoundCheckProtocol.Legogroth16
                  }],
                  long: [{
                    min: minLong,
                    max: maxLong,
                    paramId: boundCheckSnarkId,
                    protocol: BoundCheckProtocol.Legogroth16
                  }]
                }
              }
            }
          }
        }
      });
      expect(pres1.spec.credentials[1].verifiableEncryptions).toEqual({
        credentialSubject: {
          sensitive: {
            userId: [{
              chunkBitSize,
              commitmentGensId: commKeyId,
              encryptionKeyId: ekId,
              snarkKeyId: snarkPkId,
              protocol: VerifiableEncryptionProtocol.Saver
            }]
          }
        }
      });
      expect(pres1.spec.getStatus(2)).toEqual({
        id: 'dock:accumulator:accumId123',
        [TYPE_STR]: VB_ACCUMULATOR_22,
        revocationCheck: 'membership',
        accumulated: accumulator3.accumulated,
        extra: { blockNo: 2010334 }
      });

      const acc = new Map();
      acc.set(2, accumulator3Pk);

      const pp = new Map();
      pp.set(boundCheckSnarkId, boundCheckVerifyingKey);
      pp.set(commKeyId, commKey);
      pp.set(ekId, saverEk);
      pp.set(snarkPkId, saverVerifyingKey);
      checkResult(pres1.verify([pk1, pk2, pk3], acc, pp));

      checkPresentationJson(pres1, [pk1, pk2, pk3], acc, pp);
    });

    it('from a credential with subject as an array `credential5`', () => {
      const builder1 = new PresentationBuilder();
      expect(builder1.addCredential(credential5, pk1)).toEqual(0);
      builder1.markAttributesRevealed(
        0,
        new Set<string>([
          // 'credentialSubject.0.name',
          'credentialSubject.1.name',
          'credentialSubject.1.location.name',
          'credentialSubject.2.location.name'
        ])
      );
      const pres1 = builder1.finalize();

      expect(pres1.spec.credentials.length).toEqual(1);
      expect(pres1.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: [
          undefined,
          {
            name: 'Random-1',
            location: {
              name: 'Somewhere-1'
            }
          },
          {
            location: {
              name: 'Somewhere-2'
            }
          }
        ]
      });

      checkResult(pres1.verify([pk1]));

      setupBoundCheckLego();

      const boundCheckSnarkId = 'random';

      const builder2 = new PresentationBuilder();
      expect(builder2.addCredential(credential5, pk1)).toEqual(0);
      builder2.markAttributesRevealed(
        0,
        new Set<string>([
          'credentialSubject.2.location.name'
        ])
      );

      const [minLat1, maxLat1] = [25.6, 50];
      // @ts-ignore
      expect(minLat1).toBeLessThan(credential5.subject[1].location.geo.lat);
      // @ts-ignore
      expect(maxLat1).toBeGreaterThan(credential5.subject[1].location.geo.lat);
      builder2.enforceBounds(0, 'credentialSubject.1.location.geo.lat', minLat1, maxLat1, boundCheckSnarkId, boundCheckProvingKey);

      const [minLong1, maxLong1] = [-50.1, 0];
      // @ts-ignore
      expect(minLong1).toBeLessThan(credential5.subject[1].location.geo.long);
      // @ts-ignore
      expect(maxLong1).toBeGreaterThan(credential5.subject[1].location.geo.long);
      builder2.enforceBounds(0, 'credentialSubject.1.location.geo.long', minLong1, maxLong1, boundCheckSnarkId);

      const [minLat2, maxLat2] = [-70, -60];
      // @ts-ignore
      expect(minLat2).toBeLessThan(credential5.subject[2].location.geo.lat);
      // @ts-ignore
      expect(maxLat2).toBeGreaterThan(credential5.subject[2].location.geo.lat);
      builder2.enforceBounds(0, 'credentialSubject.2.location.geo.lat', minLat2, maxLat2, boundCheckSnarkId);

      const [minLong2, maxLong2] = [-10.5, -5];
      // @ts-ignore
      expect(minLong2).toBeLessThan(credential5.subject[2].location.geo.long);
      // @ts-ignore
      expect(maxLong2).toBeGreaterThan(credential5.subject[2].location.geo.long);
      builder2.enforceBounds(0, 'credentialSubject.2.location.geo.long', minLong2, maxLong2, boundCheckSnarkId);

      const pres2 = builder2.finalize();

      expect(pres2.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: [
          // Since there are no revealed attributes in the first 2 items of this array attribute
          undefined,
          undefined,
          {
            location: {
              name: 'Somewhere-2'
            }
          }
        ]
      });
      expect(pres2.spec.credentials[0].bounds).toEqual({
        credentialSubject: [
          // Since there is no bound check predicate for the first item of this array attribute
          undefined,
          {
            location: {
              geo: {
                lat: [{
                  min: minLat1,
                  max: maxLat1,
                  paramId: boundCheckSnarkId,
                  protocol: BoundCheckProtocol.Legogroth16
                }],
                long: [{
                  min: minLong1,
                  max: maxLong1,
                  paramId: boundCheckSnarkId,
                  protocol: BoundCheckProtocol.Legogroth16
                }]
              }
            }
          },
          {
            location: {
              geo: {
                lat: [{
                  min: minLat2,
                  max: maxLat2,
                  paramId: boundCheckSnarkId,
                  protocol: BoundCheckProtocol.Legogroth16
                }],
                long: [{
                  min: minLong2,
                  max: maxLong2,
                  paramId: boundCheckSnarkId,
                  protocol: BoundCheckProtocol.Legogroth16
                }]
              }
            }
          }
        ]
      });

      const pp = new Map();
      pp.set(boundCheckSnarkId, boundCheckVerifyingKey);
      checkResult(pres2.verify([pk1], undefined, pp));

      checkPresentationJson(pres2, [pk1], undefined, pp);
    });

    it('from a credential with subject as an array and top-level custom fields `credential6`', () => {
      const builder1 = new PresentationBuilder();
      expect(builder1.addCredential(credential6, pk1)).toEqual(0);
      builder1.markAttributesRevealed(
        0,
        new Set<string>([
          'credentialSubject.0.name',
          'credentialSubject.1.name',
          'credentialSubject.1.location.name',
          'credentialSubject.2.location.name',
          'issuer.desc'
        ])
      );
      const pres1 = builder1.finalize();

      expect(pres1.spec.credentials.length).toEqual(1);
      expect(pres1.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: [
          {
            name: 'Random'
          },
          {
            name: 'Random-1',
            location: {
              name: 'Somewhere-1'
            }
          },
          {
            location: {
              name: 'Somewhere-2'
            }
          }
        ],
        issuer: {
          desc: 'Just an issuer'
        }
      });

      checkResult(pres1.verify([pk1]));

      setupBoundCheckLego();

      const boundCheckSnarkId = 'random';

      const builder2 = new PresentationBuilder();
      expect(builder2.addCredential(credential6, pk1)).toEqual(0);
      builder2.markAttributesRevealed(
        0,
        new Set<string>([
          'credentialSubject.0.name',
          'credentialSubject.1.name',
          'credentialSubject.1.location.name',
          'credentialSubject.2.location.name',
          'issuer.desc'
        ])
      );

      const [minIssuanceDate, maxIssuanceDate] = [1662010848700, 1662010849900];
      // @ts-ignore
      expect(minIssuanceDate).toBeLessThan(credential6.getTopLevelField('issuanceDate'));
      // @ts-ignore
      expect(maxIssuanceDate).toBeGreaterThan(credential6.getTopLevelField('issuanceDate'));
      builder2.enforceBounds(
        0,
        'issuanceDate',
        minIssuanceDate,
        maxIssuanceDate,
        boundCheckSnarkId,
        boundCheckProvingKey
      );

      const [minExpDate, maxExpDate] = [1662011940000, 1662011980000];
      // @ts-ignore
      expect(minExpDate).toBeLessThan(credential6.getTopLevelField('expirationDate'));
      // @ts-ignore
      expect(maxExpDate).toBeGreaterThan(credential6.getTopLevelField('expirationDate'));
      builder2.enforceBounds(0, 'expirationDate', minExpDate, maxExpDate, boundCheckSnarkId);

      const pres2 = builder2.finalize();
      expect(pres2.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: [
          {
            name: 'Random'
          },
          {
            name: 'Random-1',
            location: {
              name: 'Somewhere-1'
            }
          },
          {
            location: {
              name: 'Somewhere-2'
            }
          }
        ],
        issuer: {
          desc: 'Just an issuer'
        }
      });
      expect(pres2.spec.credentials[0].bounds).toEqual({
        issuanceDate: [{
          min: minIssuanceDate,
          max: maxIssuanceDate,
          paramId: boundCheckSnarkId,
          protocol: BoundCheckProtocol.Legogroth16
        }],
        expirationDate: [{
          min: minExpDate,
          max: maxExpDate,
          paramId: boundCheckSnarkId,
          protocol: BoundCheckProtocol.Legogroth16
        }]
      });

      const pp = new Map();
      pp.set(boundCheckSnarkId, boundCheckVerifyingKey);
      checkResult(pres2.verify([pk1], undefined, pp));

      checkPresentationJson(pres2, [pk1], undefined, pp);
    });

    it('from credential with status with keyed verification', () => {
      const schema = getExampleSchema(5);
      let credSchema: CredentialSchema;
      if (withSchemaRef) {
        credSchema = new CredentialSchema(nonEmbeddedSchema, DefaultSchemaParsingOpts, true, undefined, schema);
      } else {
        credSchema = new CredentialSchema(schema);
      }
      const credBuilder = new CredentialBuilder();
      credBuilder.schema = credSchema;
      credBuilder.subject = {
        fname: 'John',
        lname: 'Smith',
        sensitive: {
          very: {
            secret: 'my-secret-that-wont-tell-anyone'
          },
          email: 'john.smith@acme.com',
          phone: '801009801',
          SSN: '123-456789-0'
        },
        lessSensitive: {
          location: {
            country: 'USA',
            city: 'New York'
          },
          department: {
            name: 'Random',
            location: {
              name: 'Somewhere',
              geo: {
                lat: -23.658,
                long: 2.556
              }
            }
          }
        },
        rank: 6
      };
      credBuilder.setCredentialStatus('dock:accumulator:accumId123', MEM_CHECK_KV_STR, 'user:A-123');
      const credential = credBuilder.sign(sk3);
      verifyCred(credential, pk3, sk3);

      const presBuilder = new PresentationBuilder();
      expect(presBuilder.addCredential(credential, pk3)).toEqual(0);
      presBuilder.markAttributesRevealed(
        0,
        new Set<string>([
          'credentialSubject.fname',
          'credentialSubject.lessSensitive.location.country',
          'credentialSubject.lessSensitive.department.location.name'
        ])
      );
      presBuilder.addAccumInfoForCredStatus(0, accumulator3Witness, accumulator3.accumulated, undefined, {
        blockNo: 2010334
      });
      const pres = presBuilder.finalize();

      expect(pres.spec.credentials[0].revealedAttributes).toEqual({
        credentialSubject: {
          fname: 'John',
          lessSensitive: { location: { country: 'USA' }, department: { location: { name: 'Somewhere' } } }
        }
      });
      // This check is made by the verifier, i.e. verifier checks that the accumulator id, type, value and timestamp (`blockNo`)
      // are as expected
      expect(pres.spec.getStatus(0)).toEqual({
        id: 'dock:accumulator:accumId123',
        [TYPE_STR]: VB_ACCUMULATOR_22,
        revocationCheck: MEM_CHECK_KV_STR,
        accumulated: accumulator3.accumulated,
        extra: { blockNo: 2010334 }
      });

      checkResult(pres.verify([pk3]));

      const presJson = pres.toJSON();

      // The schema of the credential in the presentation matches the JSON-schema
      // @ts-ignore
      checkSchemaFromJson(presJson.spec.credentials[0].schema, credential.schema);

      checkPresentationJson(pres, [pk3]);

      // Verifier passes the accumulator public key for verification
      const acc = new Map();
      acc.set(0, accumulator3Sk);
      checkResult(pres.verify([pk3], acc));
      checkPresentationJson(pres, [pk3], acc);
    })
  }
);
